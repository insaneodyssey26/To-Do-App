<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.google.services)&#10;    id(&quot;com.google.gms.google-services&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.masum.todo&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.masum.todo&quot;&#10;        minSdk = 21&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.core)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    &#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;    &#10;    implementation(libs.androidx.room.runtime)&#10;    implementation(libs.androidx.room.ktx)&#10;    kapt(libs.androidx.room.compiler)&#10;    &#10;    implementation(libs.kotlinx.coroutines.android)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended&quot;)&#10;&#10;    implementation(platform(libs.firebase.bom))&#10;    implementation(libs.firebase.auth)&#10;    implementation(libs.firebase.firestore)&#10;    implementation(libs.google.auth)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#13;&#10;    alias(libs.plugins.android.application)&#13;&#10;    alias(libs.plugins.kotlin.android)&#13;&#10;    alias(libs.plugins.kotlin.compose)&#13;&#10;    alias(libs.plugins.google.services)&#13;&#10;    id(&quot;kotlin-kapt&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;android {&#13;&#10;    namespace = &quot;com.masum.todo&quot;&#13;&#10;    compileSdk = 35&#13;&#10;&#13;&#10;    defaultConfig {&#13;&#10;        applicationId = &quot;com.masum.todo&quot;&#13;&#10;        minSdk = 23&#13;&#10;        targetSdk = 35&#13;&#10;        versionCode = 1&#13;&#10;        versionName = &quot;1.0&quot;&#13;&#10;&#13;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    buildTypes {&#13;&#10;        release {&#13;&#10;            isMinifyEnabled = false&#13;&#10;            proguardFiles(&#13;&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#13;&#10;                &quot;proguard-rules.pro&quot;&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;    compileOptions {&#13;&#10;        sourceCompatibility = JavaVersion.VERSION_11&#13;&#10;        targetCompatibility = JavaVersion.VERSION_11&#13;&#10;    }&#13;&#10;    kotlinOptions {&#13;&#10;        jvmTarget = &quot;11&quot;&#13;&#10;    }&#13;&#10;    buildFeatures {&#13;&#10;        compose = true&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;dependencies {&#13;&#10;&#13;&#10;    implementation(libs.androidx.core.ktx)&#13;&#10;    implementation(libs.androidx.core)&#13;&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#13;&#10;    implementation(libs.androidx.activity.compose)&#13;&#10;    implementation(platform(libs.androidx.compose.bom))&#13;&#10;    implementation(libs.androidx.ui)&#13;&#10;    implementation(libs.androidx.ui.graphics)&#13;&#10;    implementation(libs.androidx.ui.tooling.preview)&#13;&#10;    implementation(libs.androidx.material3)&#13;&#10;    &#13;&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#13;&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#13;&#10;    &#13;&#10;    implementation(libs.androidx.room.runtime)&#13;&#10;    implementation(libs.androidx.room.ktx)&#13;&#10;    kapt(libs.androidx.room.compiler)&#13;&#10;    &#13;&#10;    implementation(libs.kotlinx.coroutines.android)&#13;&#10;    implementation(&quot;androidx.compose.material:material-icons-extended&quot;)&#13;&#10;&#13;&#10;    implementation(platform(libs.firebase.bom))&#13;&#10;    implementation(libs.firebase.auth)&#13;&#10;    implementation(libs.firebase.firestore)&#13;&#10;    implementation(libs.google.auth)&#13;&#10;&#13;&#10;    testImplementation(libs.junit)&#13;&#10;    androidTestImplementation(libs.androidx.junit)&#13;&#10;    androidTestImplementation(libs.androidx.espresso.core)&#13;&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#13;&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#13;&#10;    debugImplementation(libs.androidx.ui.tooling)&#13;&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/androidTest/java/com/masum/todo/ExampleInstrumentedTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/androidTest/java/com/masum/todo/ExampleInstrumentedTest.kt" />
              <option name="originalContent" value="package com.masum.todo&#10;&#10;import androidx.test.platform.app.InstrumentationRegistry&#10;import androidx.test.ext.junit.runners.AndroidJUnit4&#10;&#10;import org.junit.Test&#10;import org.junit.runner.RunWith&#10;&#10;import org.junit.Assert.*&#10;&#10;/**&#10; * Instrumented test, which will execute on an Android device.&#10; *&#10; * See [testing documentation](http://d.android.com/tools/testing).&#10; */&#10;@RunWith(AndroidJUnit4::class)&#10;class ExampleInstrumentedTest {&#10;    @Test&#10;    fun useAppContext() {&#10;        // Context of the app under test.&#10;        val appContext = InstrumentationRegistry.getInstrumentation().targetContext&#10;        assertEquals(&quot;com.masum.todo&quot;, appContext.packageName)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.masum.todo&#13;&#10;&#13;&#10;import androidx.test.platform.app.InstrumentationRegistry&#13;&#10;import androidx.test.ext.junit.runners.AndroidJUnit4&#13;&#10;&#13;&#10;import org.junit.Test&#13;&#10;import org.junit.runner.RunWith&#13;&#10;&#13;&#10;import org.junit.Assert.*&#13;&#10;&#13;&#10;@RunWith(AndroidJUnit4::class)&#13;&#10;class ExampleInstrumentedTest {&#13;&#10;    @Test&#13;&#10;    fun useAppContext() {&#13;&#10;        val appContext = InstrumentationRegistry.getInstrumentation().targetContext&#13;&#10;        assertEquals(&quot;com.masum.todo&quot;, appContext.packageName)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/masum/todo/data/repository/TodoRepositoryWithSync.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/masum/todo/data/repository/TodoRepositoryWithSync.kt" />
              <option name="originalContent" value="package com.masum.todo.data.repository&#10;&#10;import com.masum.todo.data.auth.AuthService&#10;import com.masum.todo.data.sync.FirestoreSyncRepository&#10;import com.masum.todo.domain.model.TodoTask&#10;import com.masum.todo.domain.repository.TodoRepository&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;class TodoRepositoryWithSync(&#10;    private val localRepository: TodoRepositoryImpl,&#10;    private val syncRepository: FirestoreSyncRepository,&#10;    private val authService: AuthService&#10;) : TodoRepository {&#10;    &#10;    override fun getAllTasks(): Flow&lt;List&lt;TodoTask&gt;&gt; {&#10;        return localRepository.getAllTasks()&#10;    }&#10;    &#10;    override suspend fun getTaskById(id: Int): TodoTask? {&#10;        return localRepository.getTaskById(id)&#10;    }&#10;    &#10;    override suspend fun insertTask(task: TodoTask): Long {&#10;        val taskId = localRepository.insertTask(task).toLong()&#10;        &#10;        if (authService.isUserLoggedIn()) {&#10;            try {&#10;                val userId = authService.getUserId()!!&#10;                val taskWithId = task.copy(id = taskId)&#10;                syncRepository.syncTaskToCloud(userId, taskWithId)&#10;            } catch (e: Exception) {&#10;                // Log sync error but don't fail the local operation&#10;            }&#10;        }&#10;        &#10;        return taskId&#10;    }&#10;    &#10;    override suspend fun updateTask(task: TodoTask) {&#10;        localRepository.updateTask(task)&#10;        &#10;        if (authService.isUserLoggedIn()) {&#10;            try {&#10;                val userId = authService.getUserId()!!&#10;                syncRepository.syncTaskToCloud(userId, task)&#10;            } catch (e: Exception) {&#10;                // Log sync error but don't fail the local operation&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun deleteTask(task: TodoTask) {&#10;        localRepository.deleteTask(task)&#10;        &#10;        if (authService.isUserLoggedIn()) {&#10;            try {&#10;                val userId = authService.getUserId()!!&#10;                syncRepository.deleteTaskFromCloud(userId, task.id)&#10;            } catch (e: Exception) {&#10;                // Log sync error but don't fail the local operation&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun deleteTaskById(id: Int) {&#10;        localRepository.deleteTaskById(id)&#10;        &#10;        if (authService.isUserLoggedIn()) {&#10;            try {&#10;                val userId = authService.getUserId()!!&#10;                syncRepository.deleteTaskFromCloud(userId, id.toLong())&#10;            } catch (e: Exception) {&#10;                // Log sync error but don't fail the local operation&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun getTaskCount(): Int {&#10;        return localRepository.getTaskCount()&#10;    }&#10;    &#10;    override suspend fun getCompletedTaskCount(): Int {&#10;        return localRepository.getCompletedTaskCount()&#10;    }&#10;    &#10;    suspend fun syncFromCloud(): Result&lt;List&lt;TodoTask&gt;&gt; {&#10;        return try {&#10;            if (!authService.isUserLoggedIn()) {&#10;                return Result.failure(Exception(&quot;User not logged in&quot;))&#10;            }&#10;            &#10;            val userId = authService.getUserId()!!&#10;            val cloudTasks = syncRepository.getTasksFromCloud(userId)&#10;            &#10;            // Merge with local tasks (you might want more sophisticated merging logic)&#10;            cloudTasks.forEach { cloudTask -&gt;&#10;                try {&#10;                    localRepository.insertTask(cloudTask)&#10;                } catch (e: Exception) {&#10;                    // Task might already exist, try updating&#10;                    try {&#10;                        localRepository.updateTask(cloudTask)&#10;                    } catch (e: Exception) {&#10;                        // Log error&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Result.success(cloudTasks)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    suspend fun syncToCloud(tasks: List&lt;TodoTask&gt;): Result&lt;Unit&gt; {&#10;        return try {&#10;            if (!authService.isUserLoggedIn()) {&#10;                return Result.failure(Exception(&quot;User not logged in&quot;))&#10;            }&#10;            &#10;            val userId = authService.getUserId()!!&#10;            syncRepository.syncAllTasksToCloud(userId, tasks)&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.masum.todo.data.repository&#10;&#10;import com.masum.todo.data.auth.AuthService&#10;import com.masum.todo.data.sync.FirestoreSyncRepository&#10;import com.masum.todo.domain.model.TodoTask&#10;import com.masum.todo.domain.repository.TodoRepository&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;class TodoRepositoryWithSync(&#10;    private val localRepository: TodoRepositoryImpl,&#10;    private val syncRepository: FirestoreSyncRepository,&#10;    private val authService: AuthService&#10;) : TodoRepository {&#10;    &#10;    override fun getAllTasks(): Flow&lt;List&lt;TodoTask&gt;&gt; {&#10;        return localRepository.getAllTasks()&#10;    }&#10;    &#10;    override suspend fun getTaskById(id: Int): TodoTask? {&#10;        return localRepository.getTaskById(id)&#10;    }&#10;    &#10;    override suspend fun insertTask(task: TodoTask): Long {&#10;        val taskId = localRepository.insertTask(task).toLong()&#10;        &#10;        if (authService.isUserLoggedIn()) {&#10;            try {&#10;                val userId = authService.getUserId()!!&#10;                val taskWithId = task.copy(id = taskId.toInt())&#10;                syncRepository.syncTaskToCloud(userId, taskWithId)&#10;            } catch (e: Exception) {&#10;                // Log sync error but don't fail the local operation&#10;            }&#10;        }&#10;        &#10;        return taskId&#10;    }&#10;    &#10;    override suspend fun updateTask(task: TodoTask) {&#10;        localRepository.updateTask(task)&#10;        &#10;        if (authService.isUserLoggedIn()) {&#10;            try {&#10;                val userId = authService.getUserId()!!&#10;                syncRepository.syncTaskToCloud(userId, task)&#10;            } catch (e: Exception) {&#10;                // Log sync error but don't fail the local operation&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun deleteTask(task: TodoTask) {&#10;        localRepository.deleteTask(task)&#10;        &#10;        if (authService.isUserLoggedIn()) {&#10;            try {&#10;                val userId = authService.getUserId()!!&#10;                syncRepository.deleteTaskFromCloud(userId, task.id)&#10;            } catch (e: Exception) {&#10;                // Log sync error but don't fail the local operation&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun deleteTaskById(id: Int) {&#10;        localRepository.deleteTaskById(id)&#10;        &#10;        if (authService.isUserLoggedIn()) {&#10;            try {&#10;                val userId = authService.getUserId()!!&#10;                syncRepository.deleteTaskFromCloud(userId, id.toLong())&#10;            } catch (e: Exception) {&#10;                // Log sync error but don't fail the local operation&#10;            }&#10;        }&#10;    }&#10;    &#10;    override suspend fun getTaskCount(): Int {&#10;        return localRepository.getTaskCount()&#10;    }&#10;    &#10;    override suspend fun getCompletedTaskCount(): Int {&#10;        return localRepository.getCompletedTaskCount()&#10;    }&#10;    &#10;    suspend fun syncFromCloud(): Result&lt;List&lt;TodoTask&gt;&gt; {&#10;        return try {&#10;            if (!authService.isUserLoggedIn()) {&#10;                return Result.failure(Exception(&quot;User not logged in&quot;))&#10;            }&#10;            &#10;            val userId = authService.getUserId()!!&#10;            val cloudTasks = syncRepository.getTasksFromCloud(userId)&#10;            &#10;            // Merge with local tasks (you might want more sophisticated merging logic)&#10;            cloudTasks.forEach { cloudTask -&gt;&#10;                try {&#10;                    localRepository.insertTask(cloudTask)&#10;                } catch (e: Exception) {&#10;                    // Task might already exist, try updating&#10;                    try {&#10;                        localRepository.updateTask(cloudTask)&#10;                    } catch (e: Exception) {&#10;                        // Log error&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Result.success(cloudTasks)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    suspend fun syncToCloud(tasks: List&lt;TodoTask&gt;): Result&lt;Unit&gt; {&#10;        return try {&#10;            if (!authService.isUserLoggedIn()) {&#10;                return Result.failure(Exception(&quot;User not logged in&quot;))&#10;            }&#10;            &#10;            val userId = authService.getUserId()!!&#10;            syncRepository.syncAllTasksToCloud(userId, tasks)&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/TodoScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/TodoScreen.kt" />
              <option name="originalContent" value="package com.masum.todo.presentation&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.CheckCircle&#10;import androidx.compose.material.icons.filled.FilterList&#10;import androidx.compose.material.icons.filled.List&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.ExtendedFloatingActionButton&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.LargeTopAppBar&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Snackbar&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.nestedscroll.nestedScroll&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.ui.draw.scale&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.masum.todo.presentation.components.EmptyState&#10;import com.masum.todo.presentation.components.SearchAndFilterBar&#10;import com.masum.todo.presentation.components.TaskDialog&#10;import com.masum.todo.presentation.components.TodoGrid&#10;import com.masum.todo.presentation.components.TodoList&#10;import com.masum.todo.presentation.components.ViewToggleButton&#10;import com.masum.todo.presentation.viewmodel.TodoUiEvent&#10;import com.masum.todo.presentation.viewmodel.TodoViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TodoScreen(&#10;    viewModel: TodoViewModel = viewModel(),&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior()&#10;&#10;    // Safety timeout to clear persistent snackbars&#10;        if (uiState.showUndoSnackbar &amp;&amp; uiState.recentlyDeletedTask != null) {&#10;        if (uiState.showUndoSnackbar) {&#10;            kotlinx.coroutines.delay(10000) // 10 seconds timeout&#10;            if (uiState.showUndoSnackbar) { // Check if still showing&#10;                viewModel.onEvent(TodoUiEvent.ClearSnackbarMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(uiState.showUndoSnackbar, uiState.recentlyDeletedTask?.id) {&#10;        if (uiState.showUndoSnackbar &amp;&amp; uiState.recentlyDeletedTask != null) {&#10;            val result = snackbarHostState.showSnackbar(&#10;                message = &quot;Task deleted: ${uiState.recentlyDeletedTask!!.heading}&quot;,&#10;                actionLabel = &quot;Undo&quot;,&#10;                duration = androidx.compose.material3.SnackbarDuration.Long&#10;            )&#10;            // Always clear the snackbar state after it's dismissed&#10;            viewModel.onEvent(TodoUiEvent.ClearSnackbarMessage)&#10;&#10;            // If user clicked undo, restore the task&#10;            if (result == androidx.compose.material3.SnackbarResult.ActionPerformed) {&#10;                viewModel.undoDeleteTask()&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(uiState.snackbarMessage) {&#10;        uiState.snackbarMessage?.let { message -&gt;&#10;            snackbarHostState.showSnackbar(message)&#10;            viewModel.onEvent(TodoUiEvent.ClearSnackbarMessage)&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = modifier&#10;            .nestedScroll(scrollBehavior.nestedScrollConnection),&#10;        topBar = {&#10;            LargeTopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = &quot;My Tasks&quot;,&#10;                            style = MaterialTheme.typography.displayMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                        if (uiState.tasks.isNotEmpty()) {&#10;                            val completedCount = uiState.tasks.count { it.isCompleted }&#10;                            val totalCount = uiState.tasks.size&#10;                            Text(&#10;                                text = &quot;$completedCount of $totalCount completed&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                color = MaterialTheme.colorScheme.secondary,&#10;                                fontWeight = FontWeight.Medium&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                actions = {&#10;                    Row {&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.onEvent(TodoUiEvent.ToggleSearchBar)&#10;                            }&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Search,&#10;                                contentDescription = &quot;Search&quot;,&#10;                                tint = if (uiState.showSearchBar) MaterialTheme.colorScheme.primary&#10;                                       else MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        }&#10;&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.onEvent(TodoUiEvent.ToggleFilterOptions)&#10;                            }&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.FilterList,&#10;                                contentDescription = &quot;Filter&quot;,&#10;                                tint = if (uiState.showFilterOptions) MaterialTheme.colorScheme.primary&#10;                                       else MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        }&#10;&#10;                        ViewToggleButton(&#10;                            isGridView = uiState.isGridView,&#10;                            onToggleView = {&#10;                                viewModel.onEvent(TodoUiEvent.ToggleViewMode)&#10;                            }&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.largeTopAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.background,&#10;                    titleContentColor = MaterialTheme.colorScheme.onBackground&#10;                ),&#10;                scrollBehavior = scrollBehavior&#10;            )&#10;        },&#10;        snackbarHost = { &#10;            SnackbarHost(&#10;                hostState = snackbarHostState,&#10;                snackbar = { snackbarData -&gt;&#10;                    androidx.compose.material3.Snackbar(&#10;                        snackbarData = snackbarData,&#10;                        containerColor = MaterialTheme.colorScheme.inverseSurface,&#10;                        contentColor = MaterialTheme.colorScheme.inverseOnSurface,&#10;                        actionColor = MaterialTheme.colorScheme.inversePrimary,&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                    )&#10;                }&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            val fabScale by animateFloatAsState(&#10;                targetValue = if (uiState.isLoading) 0.8f else 1f,&#10;                animationSpec = tween(300),&#10;                label = &quot;fab_scale&quot;&#10;                containerColor = MaterialTheme.colorScheme.primary,&#10;                contentColor = MaterialTheme.colorScheme.onPrimary,&#10;                modifier = Modifier.scale(fabScale)&#10;            ) {&#10;                Icon(&#10;                    Icons.Default.Add, &#10;                    contentDescription = &quot;Create Task&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = &quot;Create Task&quot;,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                val tasksToShow = if (uiState.searchQuery.isNotEmpty() ||&#10;                                    uiState.selectedFilter != com.masum.todo.presentation.viewmodel.FilterType.ALL) {&#10;                    uiState.filteredTasks&#10;                } else {&#10;                    uiState.tasks&#10;                }&#10;&#10;                    Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.1f),&#10;                            MaterialTheme.colorScheme.background&#10;                        )&#10;                    )&#10;                )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(innerPadding)&#10;                    .fillMaxSize()&#10;            ) {&#10;                val tasksToShow = if (uiState.searchQuery.isNotEmpty() ||&#10;                                    uiState.selectedFilter != com.masum.todo.presentation.viewmodel.FilterType.ALL) {&#10;                    uiState.filteredTasks&#10;                } else {&#10;                    uiState.tasks&#10;                }&#10;                SearchAndFilterBar(&#10;                    searchQuery = uiState.searchQuery,&#10;                    selectedFilter = uiState.selectedFilter,&#10;                    selectedSort = uiState.selectedSort,&#10;                    showSearchBar = uiState.showSearchBar,&#10;                    showFilterOptions = uiState.showFilterOptions,&#10;                    filteredTasksCount = tasksToShow.size,&#10;                    onSearchQueryChange = { query -&gt;&#10;                        viewModel.onEvent(TodoUiEvent.UpdateSearchQuery(query))&#10;                    },&#10;                    onFilterChange = { filter -&gt;&#10;                        viewModel.onEvent(TodoUiEvent.UpdateFilter(filter))&#10;                    },&#10;                    onSortChange = { sort -&gt;&#10;                        viewModel.onEvent(TodoUiEvent.UpdateSort(sort))&#10;                    },&#10;                    onClearSearch = {&#10;                        viewModel.onEvent(TodoUiEvent.ClearSearch)&#10;                    }&#10;                )&#10;&#10;                if (uiState.tasks.isNotEmpty()) {&#10;                    TaskSummaryCard(&#10;                        totalTasks = uiState.tasks.size,&#10;                        completedTasks = uiState.tasks.count { it.isCompleted },&#10;                        filteredCount = if (tasksToShow != uiState.tasks) tasksToShow.size else null,&#10;                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                    )&#10;                }&#10;&#10;                when {&#10;                    uiState.isLoading -&gt; {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                color = MaterialTheme.colorScheme.primary,&#10;                                strokeWidth = 3.dp&#10;                            )&#10;                        }&#10;                    }&#10;                    uiState.tasks.isEmpty() -&gt; {&#10;                        EmptyState()&#10;                    }&#10;                    tasksToShow.isEmpty() -&gt; {&#10;                        EmptySearchState()&#10;                    }&#10;                    else -&gt; {&#10;                        if (uiState.isGridView) {&#10;                            TodoGrid(&#10;                                tasks = tasksToShow,&#10;                                onTaskChecked = { task, isChecked -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.ToggleTaskCompletion(task, isChecked))&#10;                                },&#10;                                onDeleteTask = { task -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.DeleteTask(task))&#10;                                },&#10;                                onEditTask = { task -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.ShowTaskEditorForEdit(task))&#10;                                }&#10;                            )&#10;                        } else {&#10;                            TodoList(&#10;                                tasks = tasksToShow,&#10;                                onTaskChecked = { task, isChecked -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.ToggleTaskCompletion(task, isChecked))&#10;                                },&#10;                                onDeleteTask = { task -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.DeleteTask(task))&#10;                                },&#10;                                onEditTask = { task -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.ShowTaskEditorForEdit(task))&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (uiState.showAddDialog) {&#10;        TaskDialog(&#10;            dialogTitle = &quot;Add New Task&quot;,&#10;            taskHeading = uiState.currentTaskHeading,&#10;            taskBody = uiState.currentTaskBody,&#10;            taskColor = uiState.currentTaskColor,&#10;            onHeadingChange = { heading -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskHeading(heading))&#10;            },&#10;            onBodyChange = { body -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskBody(body))&#10;            },&#10;            onColorChange = { color -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskColor(color))&#10;            onDismiss = {&#10;            taskId = uiState.taskToEdit?.id,&#10;            existingTask = uiState.taskToEdit,&#10;            onConfirm = {&#10;                viewModel.onEvent(TodoUiEvent.AddTask(uiState.currentTaskHeading, uiState.currentTaskBody))&#10;            },&#10;            confirmButtonText = &quot;Add&quot;&#10;                if (uiState.taskToEdit != null) {&#10;                    val updatedTask = uiState.taskToEdit.copy(&#10;&#10;    if (uiState.showEditDialog &amp;&amp; uiState.taskToEdit != null) {&#10;        TaskDialog(&#10;            dialogTitle = &quot;Edit Task&quot;,&#10;            taskHeading = uiState.currentTaskHeading,&#10;            taskBody = uiState.currentTaskBody,&#10;            taskColor = uiState.currentTaskColor,&#10;            onHeadingChange = { heading -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskHeading(heading))&#10;            },&#10;            onBodyChange = { body -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskBody(body))&#10;            },&#10;            onColorChange = { color -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskColor(color))&#10;            },&#10;            onDismiss = {&#10;                viewModel.onEvent(TodoUiEvent.HideEditDialog)&#10;            },&#10;            onConfirm = {&#10;                uiState.taskToEdit?.let { task -&gt;&#10;                    viewModel.onEvent(TodoUiEvent.UpdateTask(task))&#10;                }&#10;            },&#10;            confirmButtonText = &quot;Save&quot;&#10;        )&#10;    }&#10;&#10;&#10;    if (uiState.showTaskEditor) {&#10;        val taskToEdit = uiState.taskToEdit&#10;        TaskEditorScreen(&#10;            taskId = taskToEdit?.id,&#10;            existingTask = taskToEdit,&#10;            onNavigateBack = {&#10;                viewModel.onEvent(TodoUiEvent.HideTaskEditor)&#10;            },&#10;            onSaveTask = { heading, body, color, priority, dueDate, tags -&gt;&#10;                if (taskToEdit != null) {&#10;                    val updatedTask = taskToEdit.copy(&#10;                        heading = heading,&#10;                        body = body,&#10;                        color = color,&#10;                        priority = priority,&#10;                        dueDate = dueDate,&#10;                        tags = tags&#10;                    )&#10;                    viewModel.onEvent(TodoUiEvent.UpdateTask(updatedTask))&#10;                } else {&#10;                    viewModel.onEvent(&#10;                        TodoUiEvent.AddAdvancedTask(&#10;                            heading = heading,&#10;                            body = body,&#10;                            color = color,&#10;                            priority = priority,&#10;                            dueDate = dueDate,&#10;                            tags = tags&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EmptySearchState(&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Search,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(64.dp),&#10;                tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;No tasks found&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                color = MaterialTheme.colorScheme.onSurface,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;Try adjusting your search or filters&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun TaskSummaryCard(&#10;    totalTasks: Int,&#10;    completedTasks: Int,&#10;    filteredCount: Int? = null,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            horizontalArrangement = Arrangement.SpaceEvenly,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            TaskStatItem(&#10;                icon = Icons.Default.List,&#10;                label = &quot;Total&quot;,&#10;                count = totalTasks,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            TaskStatItem(&#10;                icon = Icons.Default.CheckCircle,&#10;                label = &quot;Completed&quot;,&#10;                count = completedTasks,&#10;                color = Color(0xFF4CAF50)&#10;            )&#10;&#10;            if (filteredCount != null) {&#10;                TaskStatItem(&#10;                    icon = Icons.Default.FilterList,&#10;                    label = &quot;Filtered&quot;,&#10;                    count = filteredCount,&#10;                    color = MaterialTheme.colorScheme.secondary&#10;                )&#10;            } else {&#10;                TaskStatItem(&#10;                    icon = Icons.Default.List,&#10;                    label = &quot;Remaining&quot;,&#10;                    count = totalTasks - completedTasks,&#10;                    color = MaterialTheme.colorScheme.tertiary&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun TaskStatItem(&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    label: String,&#10;    count: Int,&#10;    color: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = modifier&#10;    ) {&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = label,&#10;            tint = color,&#10;            modifier = Modifier&#10;                .size(32.dp)&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .background(color.copy(alpha = 0.1f))&#10;                .padding(6.dp)&#10;        )&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Text(&#10;            text = count.toString(),&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            fontWeight = FontWeight.Bold,&#10;            color = color&#10;        )&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.masum.todo.presentation&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.CheckCircle&#10;import androidx.compose.material.icons.filled.FilterList&#10;import androidx.compose.material.icons.filled.List&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.ExtendedFloatingActionButton&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.LargeTopAppBar&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Snackbar&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.nestedscroll.nestedScroll&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.ui.draw.scale&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.masum.todo.presentation.components.EmptyState&#10;import com.masum.todo.presentation.components.SearchAndFilterBar&#10;import com.masum.todo.presentation.components.TaskDialog&#10;import com.masum.todo.presentation.components.TodoGrid&#10;import com.masum.todo.presentation.components.TodoList&#10;import com.masum.todo.presentation.components.ViewToggleButton&#10;import com.masum.todo.presentation.viewmodel.TodoUiEvent&#10;import com.masum.todo.presentation.viewmodel.TodoViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TodoScreen(&#10;    viewModel: TodoViewModel = viewModel(),&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;    val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior()&#10;&#10;    LaunchedEffect(uiState.showUndoSnackbar) {&#10;        if (uiState.showUndoSnackbar) {&#10;            kotlinx.coroutines.delay(10000)&#10;            if (uiState.showUndoSnackbar) {&#10;                viewModel.onEvent(TodoUiEvent.ClearSnackbarMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(uiState.showUndoSnackbar, uiState.recentlyDeletedTask?.id) {&#10;        if (uiState.showUndoSnackbar &amp;&amp; uiState.recentlyDeletedTask != null) {&#10;            val result = snackbarHostState.showSnackbar(&#10;                message = &quot;Task deleted: ${uiState.recentlyDeletedTask!!.heading}&quot;,&#10;                actionLabel = &quot;Undo&quot;,&#10;                duration = androidx.compose.material3.SnackbarDuration.Long&#10;            )&#10;            viewModel.onEvent(TodoUiEvent.ClearSnackbarMessage)&#10;            if (result == androidx.compose.material3.SnackbarResult.ActionPerformed) {&#10;                viewModel.undoDeleteTask()&#10;            }&#10;        }&#10;    }&#10;    LaunchedEffect(uiState.snackbarMessage) {&#10;        uiState.snackbarMessage?.let { message -&gt;&#10;            snackbarHostState.showSnackbar(message)&#10;            viewModel.onEvent(TodoUiEvent.ClearSnackbarMessage)&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = modifier&#10;            .nestedScroll(scrollBehavior.nestedScrollConnection),&#10;        topBar = {&#10;            LargeTopAppBar(&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = &quot;My Tasks&quot;,&#10;                            style = MaterialTheme.typography.displayMedium,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                        if (uiState.tasks.isNotEmpty()) {&#10;                            val completedCount = uiState.tasks.count { it.isCompleted }&#10;                            val totalCount = uiState.tasks.size&#10;                            Text(&#10;                                text = &quot;$completedCount of $totalCount completed&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                color = MaterialTheme.colorScheme.secondary,&#10;                                fontWeight = FontWeight.Medium&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                actions = {&#10;                    Row {&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.onEvent(TodoUiEvent.ToggleSearchBar)&#10;                            }&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Search,&#10;                                contentDescription = &quot;Search&quot;,&#10;                                tint = if (uiState.showSearchBar) MaterialTheme.colorScheme.primary&#10;                                       else MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        }&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.onEvent(TodoUiEvent.ToggleFilterOptions)&#10;                            }&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.FilterList,&#10;                                contentDescription = &quot;Filter&quot;,&#10;                                tint = if (uiState.showFilterOptions) MaterialTheme.colorScheme.primary&#10;                                       else MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        }&#10;                        ViewToggleButton(&#10;                            isGridView = uiState.isGridView,&#10;                            onToggleView = {&#10;                                viewModel.onEvent(TodoUiEvent.ToggleViewMode)&#10;                            }&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.largeTopAppBarColors(&#10;                    containerColor = MaterialTheme.colorScheme.background,&#10;                    titleContentColor = MaterialTheme.colorScheme.onBackground&#10;                ),&#10;                scrollBehavior = scrollBehavior&#10;            )&#10;        },&#10;        snackbarHost = { &#10;            SnackbarHost(&#10;                hostState = snackbarHostState,&#10;                snackbar = { snackbarData -&gt;&#10;                    androidx.compose.material3.Snackbar(&#10;                        snackbarData = snackbarData,&#10;                        containerColor = MaterialTheme.colorScheme.inverseSurface,&#10;                        contentColor = MaterialTheme.colorScheme.inverseOnSurface,&#10;                        actionColor = MaterialTheme.colorScheme.inversePrimary,&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                    )&#10;                }&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            val fabScale by animateFloatAsState(&#10;                targetValue = if (uiState.isLoading) 0.8f else 1f,&#10;                animationSpec = tween(300),&#10;                label = &quot;fab_scale&quot;&#10;            )&#10;            ExtendedFloatingActionButton(&#10;                onClick = {&#10;                    viewModel.onEvent(TodoUiEvent.ShowTaskEditor)&#10;                },&#10;                containerColor = MaterialTheme.colorScheme.primary,&#10;                contentColor = MaterialTheme.colorScheme.onPrimary,&#10;                modifier = Modifier.scale(fabScale)&#10;            ) {&#10;                Icon(&#10;                    Icons.Default.Add, &#10;                    contentDescription = &quot;Create Task&quot;,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = &quot;Create Task&quot;,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;            }&#10;        }&#10;    ) { innerPadding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                    Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.1f),&#10;                            MaterialTheme.colorScheme.background&#10;                        )&#10;                    )&#10;                )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(innerPadding)&#10;                    .fillMaxSize()&#10;            ) {&#10;                val tasksToShow = if (uiState.searchQuery.isNotEmpty() ||&#10;                                    uiState.selectedFilter != com.masum.todo.presentation.viewmodel.FilterType.ALL) {&#10;                    uiState.filteredTasks&#10;                } else {&#10;                    uiState.tasks&#10;                }&#10;                SearchAndFilterBar(&#10;                    searchQuery = uiState.searchQuery,&#10;                    selectedFilter = uiState.selectedFilter,&#10;                    selectedSort = uiState.selectedSort,&#10;                    showSearchBar = uiState.showSearchBar,&#10;                    showFilterOptions = uiState.showFilterOptions,&#10;                    filteredTasksCount = tasksToShow.size,&#10;                    onSearchQueryChange = { query -&gt;&#10;                        viewModel.onEvent(TodoUiEvent.UpdateSearchQuery(query))&#10;                    },&#10;                    onFilterChange = { filter -&gt;&#10;                        viewModel.onEvent(TodoUiEvent.UpdateFilter(filter))&#10;                    },&#10;                    onSortChange = { sort -&gt;&#10;                        viewModel.onEvent(TodoUiEvent.UpdateSort(sort))&#10;                    },&#10;                    onClearSearch = {&#10;                        viewModel.onEvent(TodoUiEvent.ClearSearch)&#10;                    }&#10;                )&#10;                if (uiState.tasks.isNotEmpty()) {&#10;                    TaskSummaryCard(&#10;                        totalTasks = uiState.tasks.size,&#10;                        completedTasks = uiState.tasks.count { it.isCompleted },&#10;                        filteredCount = if (tasksToShow != uiState.tasks) tasksToShow.size else null,&#10;                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                    )&#10;                }&#10;                when {&#10;                    uiState.isLoading -&gt; {&#10;                        Box(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                color = MaterialTheme.colorScheme.primary,&#10;                                strokeWidth = 3.dp&#10;                            )&#10;                        }&#10;                    }&#10;                    uiState.tasks.isEmpty() -&gt; {&#10;                        EmptyState()&#10;                    }&#10;                    tasksToShow.isEmpty() -&gt; {&#10;                        EmptySearchState()&#10;                    }&#10;                    else -&gt; {&#10;                        if (uiState.isGridView) {&#10;                            TodoGrid(&#10;                                tasks = tasksToShow,&#10;                                onTaskChecked = { task, isChecked -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.ToggleTaskCompletion(task, isChecked))&#10;                                },&#10;                                onDeleteTask = { task -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.DeleteTask(task))&#10;                                },&#10;                                onEditTask = { task -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.ShowTaskEditorForEdit(task))&#10;                                }&#10;                            )&#10;                        } else {&#10;                            TodoList(&#10;                                tasks = tasksToShow,&#10;                                onTaskChecked = { task, isChecked -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.ToggleTaskCompletion(task, isChecked))&#10;                                },&#10;                                onDeleteTask = { task -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.DeleteTask(task))&#10;                                },&#10;                                onEditTask = { task -&gt;&#10;                                    viewModel.onEvent(TodoUiEvent.ShowTaskEditorForEdit(task))&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    if (uiState.showAddDialog) {&#10;        TaskDialog(&#10;            dialogTitle = &quot;Add New Task&quot;,&#10;            taskHeading = uiState.currentTaskHeading,&#10;            taskBody = uiState.currentTaskBody,&#10;            taskColor = uiState.currentTaskColor,&#10;            onHeadingChange = { heading -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskHeading(heading))&#10;            },&#10;            onBodyChange = { body -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskBody(body))&#10;            },&#10;            onColorChange = { color -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskColor(color))&#10;            },&#10;            onDismiss = {&#10;                viewModel.onEvent(TodoUiEvent.HideAddDialog)&#10;            },&#10;            onConfirm = {&#10;                viewModel.onEvent(TodoUiEvent.AddTask(uiState.currentTaskHeading, uiState.currentTaskBody))&#10;            },&#10;            confirmButtonText = &quot;Add&quot;&#10;        )&#10;    }&#10;    if (uiState.showEditDialog &amp;&amp; uiState.taskToEdit != null) {&#10;        TaskDialog(&#10;            dialogTitle = &quot;Edit Task&quot;,&#10;            taskHeading = uiState.currentTaskHeading,&#10;            taskBody = uiState.currentTaskBody,&#10;            taskColor = uiState.currentTaskColor,&#10;            onHeadingChange = { heading -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskHeading(heading))&#10;            },&#10;            onBodyChange = { body -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskBody(body))&#10;            },&#10;            onColorChange = { color -&gt;&#10;                viewModel.onEvent(TodoUiEvent.UpdateCurrentTaskColor(color))&#10;            },&#10;            onDismiss = {&#10;                viewModel.onEvent(TodoUiEvent.HideEditDialog)&#10;            },&#10;            onConfirm = {&#10;                uiState.taskToEdit?.let { task -&gt;&#10;                    viewModel.onEvent(TodoUiEvent.UpdateTask(task))&#10;                }&#10;            },&#10;            confirmButtonText = &quot;Save&quot;&#10;        )&#10;    }&#10;    if (uiState.showTaskEditor) {&#10;        val taskToEdit = uiState.taskToEdit&#10;        TaskEditorScreen(&#10;            taskId = taskToEdit?.id,&#10;            existingTask = taskToEdit,&#10;            onNavigateBack = {&#10;                viewModel.onEvent(TodoUiEvent.HideTaskEditor)&#10;            },&#10;            onSaveTask = { heading, body, color, priority, dueDate, tags -&gt;&#10;                if (taskToEdit != null) {&#10;                    val updatedTask = taskToEdit.copy(&#10;                        heading = heading,&#10;                        body = body,&#10;                        color = color,&#10;                        priority = priority,&#10;                        dueDate = dueDate,&#10;                        tags = tags&#10;                    )&#10;                    viewModel.onEvent(TodoUiEvent.UpdateTask(updatedTask))&#10;                } else {&#10;                    viewModel.onEvent(&#10;                        TodoUiEvent.AddAdvancedTask(&#10;                            heading = heading,&#10;                            body = body,&#10;                            color = color,&#10;                            priority = priority,&#10;                            dueDate = dueDate,&#10;                            tags = tags&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EmptySearchState(&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Search,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(64.dp),&#10;                tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;No tasks found&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                color = MaterialTheme.colorScheme.onSurface,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;Try adjusting your search or filters&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun TaskSummaryCard(&#10;    totalTasks: Int,&#10;    completedTasks: Int,&#10;    filteredCount: Int? = null,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(20.dp),&#10;            horizontalArrangement = Arrangement.SpaceEvenly,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            TaskStatItem(&#10;                icon = Icons.Default.List,&#10;                label = &quot;Total&quot;,&#10;                count = totalTasks,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;            TaskStatItem(&#10;                icon = Icons.Default.CheckCircle,&#10;                label = &quot;Completed&quot;,&#10;                count = completedTasks,&#10;                color = Color(0xFF4CAF50)&#10;            )&#10;            if (filteredCount != null) {&#10;                TaskStatItem(&#10;                    icon = Icons.Default.FilterList,&#10;                    label = &quot;Filtered&quot;,&#10;                    count = filteredCount,&#10;                    color = MaterialTheme.colorScheme.secondary&#10;                )&#10;            } else {&#10;                TaskStatItem(&#10;                    icon = Icons.Default.List,&#10;                    label = &quot;Remaining&quot;,&#10;                    count = totalTasks - completedTasks,&#10;                    color = MaterialTheme.colorScheme.tertiary&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun TaskStatItem(&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    label: String,&#10;    count: Int,&#10;    color: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = modifier&#10;    ) {&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = label,&#10;            tint = color,&#10;            modifier = Modifier&#10;                .size(32.dp)&#10;                .clip(RoundedCornerShape(8.dp))&#10;                .background(color.copy(alpha = 0.1f))&#10;                .padding(6.dp)&#10;        )&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Text(&#10;            text = count.toString(),&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            fontWeight = FontWeight.Bold,&#10;            color = color&#10;        )&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/components/SearchAndFilterBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/components/SearchAndFilterBar.kt" />
              <option name="originalContent" value="package com.masum.todo.presentation.components&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.expandVertically&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.shrinkVertically&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.ExperimentalLayoutApi&#10;import androidx.compose.foundation.layout.FlowRow&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Clear&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.FilterChip&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;import com.masum.todo.presentation.viewmodel.FilterType&#10;import com.masum.todo.presentation.viewmodel.SortType&#10;&#10;@OptIn(ExperimentalLayoutApi::class)&#10;@Composable&#10;fun SearchAndFilterBar(&#10;    searchQuery: String,&#10;    selectedFilter: FilterType,&#10;    selectedSort: SortType,&#10;    showSearchBar: Boolean,&#10;    showFilterOptions: Boolean,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    onFilterChange: (FilterType) -&gt; Unit,&#10;    onSortChange: (SortType) -&gt; Unit,&#10;    onClearSearch: () -&gt; Unit,&#10;    filteredTasksCount: Int = 0,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    &#10;    Column(modifier = modifier) {&#10;        AnimatedVisibility(&#10;            visible = showSearchBar,&#10;            enter = expandVertically() + fadeIn(),&#10;            exit = shrinkVertically() + fadeOut()&#10;        ) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;                shape = RoundedCornerShape(16.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = searchQuery,&#10;                    onValueChange = onSearchQueryChange,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    placeholder = { Text(&quot;Search tasks, tags, or content...&quot;) },&#10;                    leadingIcon = {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Search,&#10;                            contentDescription = &quot;Search&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    },&#10;                    trailingIcon = {&#10;                        if (searchQuery.isNotEmpty()) {&#10;                            IconButton(onClick = onClearSearch) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Clear,&#10;                                    contentDescription = &quot;Clear search&quot;,&#10;                                    tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    },&#10;                    singleLine = true,&#10;                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;                    keyboardActions = KeyboardActions(&#10;                        onSearch = { keyboardController?.hide() }&#10;                    ),&#10;                    shape = RoundedCornerShape(12.dp)&#10;                )&#10;                &#10;                if (searchQuery.isNotEmpty()) {&#10;                    Text(&#10;                        text = &quot;$filteredTasksCount results found&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.padding(start = 16.dp, bottom = 8.dp)&#10;                    )&#10;                }&#10;                &#10;                FlowRow(&#10;                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    val quickFilters = listOf(&#10;                        FilterType.TODAY to &quot;Today&quot;,&#10;                        FilterType.OVERDUE to &quot;Overdue&quot;,&#10;                        FilterType.HIGH_PRIORITY to &quot;High Priority&quot;,&#10;                        FilterType.PENDING to &quot;Active&quot;&#10;                    )&#10;                    &#10;                    quickFilters.forEach { (filter, label) -&gt;&#10;                        FilterChip(&#10;                            selected = selectedFilter == filter,&#10;                            onClick = { onFilterChange(filter) },&#10;                            label = { Text(label, style = MaterialTheme.typography.bodySmall) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        &#10;        AnimatedVisibility(&#10;            visible = showFilterOptions,&#10;            enter = expandVertically() + fadeIn(),&#10;            exit = shrinkVertically() + fadeOut()&#10;        ) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;                shape = RoundedCornerShape(16.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Smart Lists&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    &#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    &#10;                    FlowRow(&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        val smartFilters = listOf(&#10;                            FilterType.ALL to &quot;All Tasks&quot;,&#10;                            FilterType.TODAY to &quot;Due Today&quot;,&#10;                            FilterType.OVERDUE to &quot;Overdue&quot;,&#10;                            FilterType.PENDING to &quot;Active&quot;,&#10;                            FilterType.COMPLETED to &quot;Completed&quot;,&#10;                            FilterType.HIGH_PRIORITY to &quot;High Priority&quot;,&#10;                            FilterType.WITH_DUE_DATE to &quot;With Due Date&quot;,&#10;                            FilterType.NO_DUE_DATE to &quot;No Due Date&quot;&#10;                        )&#10;                        &#10;                        smartFilters.forEach { (filter, label) -&gt;&#10;                            FilterChip(&#10;                                selected = selectedFilter == filter,&#10;                                onClick = { onFilterChange(filter) },&#10;                                label = { Text(label) },&#10;                                leadingIcon = {&#10;                                    val color = when (filter) {&#10;                                        FilterType.OVERDUE -&gt; Color.Red&#10;                                        FilterType.TODAY -&gt; Color(0xFFFF9800)&#10;                                        FilterType.HIGH_PRIORITY -&gt; Color(0xFFE91E63)&#10;                                        FilterType.COMPLETED -&gt; Color(0xFF4CAF50)&#10;                                        FilterType.PENDING -&gt; Color(0xFF2196F3)&#10;                                        else -&gt; MaterialTheme.colorScheme.primary&#10;                                    }&#10;                                    Box(&#10;                                        modifier = Modifier&#10;                                            .size(8.dp)&#10;                                            .background(color, CircleShape)&#10;                                    )&#10;                                }&#10;                            )&#10;                        }&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    &#10;                    Text(&#10;                        text = &quot;Sort By&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.SemiBold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    )&#10;                    &#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    &#10;                    FlowRow(&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        val sortOptions = listOf(&#10;                            SortType.CREATED_DATE to &quot;Created Date&quot;,&#10;                            SortType.DUE_DATE to &quot;Due Date&quot;,&#10;                            SortType.PRIORITY to &quot;Priority&quot;,&#10;                            SortType.ALPHABETICAL to &quot;A-Z&quot;,&#10;                            SortType.COMPLETION_STATUS to &quot;Status&quot;&#10;                        )&#10;                        &#10;                        sortOptions.forEach { (sort, label) -&gt;&#10;                            FilterChip(&#10;                                selected = selectedSort == sort,&#10;                                onClick = { onSortChange(sort) },&#10;                                label = { Text(label) }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.masum.todo.presentation.components&#13;&#10;&#13;&#10;import androidx.compose.animation.AnimatedVisibility&#13;&#10;import androidx.compose.animation.expandVertically&#13;&#10;import androidx.compose.animation.fadeIn&#13;&#10;import androidx.compose.animation.fadeOut&#13;&#10;import androidx.compose.animation.shrinkVertically&#13;&#10;import androidx.compose.foundation.background&#13;&#10;import androidx.compose.foundation.clickable&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.material.icons.Icons&#13;&#10;import androidx.compose.material.icons.filled.Clear&#13;&#10;import androidx.compose.material3.*&#13;&#10;import androidx.compose.runtime.Composable&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#13;&#10;import androidx.compose.ui.text.font.FontWeight&#13;&#10;import androidx.compose.ui.text.input.ImeAction&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import com.masum.todo.presentation.viewmodel.FilterType&#13;&#10;import com.masum.todo.presentation.viewmodel.SortType&#13;&#10;&#13;&#10;@OptIn(ExperimentalLayoutApi::class)&#13;&#10;@Composable&#13;&#10;fun SearchAndFilterBar(&#13;&#10;    searchQuery: String,&#13;&#10;    selectedFilter: FilterType,&#13;&#10;    selectedSort: SortType,&#13;&#10;    showSearchBar: Boolean,&#13;&#10;    showFilterOptions: Boolean,&#13;&#10;    filteredTasksCount: Int,&#13;&#10;    onSearchQueryChange: (String) -&gt; Unit,&#13;&#10;    onFilterChange: (FilterType) -&gt; Unit,&#13;&#10;    onSortChange: (SortType) -&gt; Unit,&#13;&#10;    onClearSearch: () -&gt; Unit,&#13;&#10;    modifier: Modifier = Modifier&#13;&#10;) {&#13;&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#13;&#10;    &#13;&#10;    Column(modifier = modifier.fillMaxWidth().padding(horizontal = 16.dp, vertical = 8.dp)) {&#13;&#10;        if (showSearchBar) {&#13;&#10;            Card(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#13;&#10;                colors = CardDefaults.cardColors(&#13;&#10;                    containerColor = MaterialTheme.colorScheme.surface&#13;&#10;                ),&#13;&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#13;&#10;                shape = RoundedCornerShape(16.dp)&#13;&#10;            ) {&#13;&#10;                OutlinedTextField(&#13;&#10;                    value = searchQuery,&#13;&#10;                    onValueChange = onSearchQueryChange,&#13;&#10;                    modifier = Modifier&#13;&#10;                        .fillMaxWidth()&#13;&#10;                        .padding(16.dp),&#13;&#10;                    placeholder = { Text(&quot;Search tasks, tags, or content...&quot;) },&#13;&#10;                    leadingIcon = {&#13;&#10;                        Icon(&#13;&#10;                            imageVector = Icons.Default.Search,&#13;&#10;                            contentDescription = &quot;Search&quot;,&#13;&#10;                            tint = MaterialTheme.colorScheme.primary&#13;&#10;                        )&#13;&#10;                    },&#13;&#10;                    trailingIcon = {&#13;&#10;                        if (searchQuery.isNotEmpty()) {&#13;&#10;                            IconButton(onClick = onClearSearch) {&#13;&#10;                                Icon(&#13;&#10;                                    imageVector = Icons.Default.Clear,&#13;&#10;                                    contentDescription = &quot;Clear search&quot;,&#13;&#10;                                    tint = MaterialTheme.colorScheme.onSurfaceVariant&#13;&#10;                                )&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    },&#13;&#10;                    singleLine = true,&#13;&#10;                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#13;&#10;                    keyboardActions = KeyboardActions(&#13;&#10;                        onSearch = { keyboardController?.hide() }&#13;&#10;                    ),&#13;&#10;                    shape = RoundedCornerShape(12.dp)&#13;&#10;                )&#13;&#10;                &#13;&#10;                if (searchQuery.isNotEmpty()) {&#13;&#10;                    Text(&#13;&#10;                        text = &quot;$filteredTasksCount results found&quot;,&#13;&#10;                        style = MaterialTheme.typography.bodySmall,&#13;&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#13;&#10;                        modifier = Modifier.padding(start = 16.dp, bottom = 8.dp)&#13;&#10;                    )&#13;&#10;                }&#13;&#10;                &#13;&#10;                FlowRow(&#13;&#10;                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),&#13;&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp),&#13;&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;                ) {&#13;&#10;                    val quickFilters = listOf(&#13;&#10;                        FilterType.TODAY to &quot;Today&quot;,&#13;&#10;                        FilterType.OVERDUE to &quot;Overdue&quot;,&#13;&#10;                        FilterType.HIGH_PRIORITY to &quot;High Priority&quot;,&#13;&#10;                        FilterType.PENDING to &quot;Active&quot;&#13;&#10;                    )&#13;&#10;                    &#13;&#10;                    quickFilters.forEach { (filter, label) -&gt;&#13;&#10;                        FilterChip(&#13;&#10;                            selected = selectedFilter == filter,&#13;&#10;                            onClick = { onFilterChange(filter) },&#13;&#10;                            label = { Text(label, style = MaterialTheme.typography.bodySmall) }&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;        &#13;&#10;        if (showFilterOptions) {&#13;&#10;            Card(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxWidth()&#13;&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#13;&#10;                colors = CardDefaults.cardColors(&#13;&#10;                    containerColor = MaterialTheme.colorScheme.surface&#13;&#10;                ),&#13;&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#13;&#10;                shape = RoundedCornerShape(16.dp)&#13;&#10;            ) {&#13;&#10;                Column(&#13;&#10;                    modifier = Modifier.padding(16.dp)&#13;&#10;                ) {&#13;&#10;                    Text(&#13;&#10;                        text = &quot;Smart Lists&quot;,&#13;&#10;                        style = MaterialTheme.typography.titleMedium,&#13;&#10;                        fontWeight = FontWeight.SemiBold,&#13;&#10;                        color = MaterialTheme.colorScheme.primary&#13;&#10;                    )&#13;&#10;                    &#13;&#10;                    Spacer(modifier = Modifier.height(12.dp))&#13;&#10;                    &#13;&#10;                    FlowRow(&#13;&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp),&#13;&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;                    ) {&#13;&#10;                        val smartFilters = listOf(&#13;&#10;                            FilterType.ALL to &quot;All Tasks&quot;,&#13;&#10;                            FilterType.TODAY to &quot;Due Today&quot;,&#13;&#10;                            FilterType.OVERDUE to &quot;Overdue&quot;,&#13;&#10;                            FilterType.PENDING to &quot;Active&quot;,&#13;&#10;                            FilterType.COMPLETED to &quot;Completed&quot;,&#13;&#10;                            FilterType.HIGH_PRIORITY to &quot;High Priority&quot;,&#13;&#10;                            FilterType.WITH_DUE_DATE to &quot;With Due Date&quot;,&#13;&#10;                            FilterType.NO_DUE_DATE to &quot;No Due Date&quot;&#13;&#10;                        )&#13;&#10;                        &#13;&#10;                        smartFilters.forEach { (filter, label) -&gt;&#13;&#10;                            FilterChip(&#13;&#10;                                selected = selectedFilter == filter,&#13;&#10;                                onClick = { onFilterChange(filter) },&#13;&#10;                                label = { Text(label) },&#13;&#10;                                leadingIcon = {&#13;&#10;                                    val color = when (filter) {&#13;&#10;                                        FilterType.OVERDUE -&gt; Color.Red&#13;&#10;                                        FilterType.TODAY -&gt; Color(0xFFFF9800)&#13;&#10;                                        FilterType.HIGH_PRIORITY -&gt; Color(0xFFE91E63)&#13;&#10;                                        FilterType.COMPLETED -&gt; Color(0xFF4CAF50)&#13;&#10;                                        FilterType.PENDING -&gt; Color(0xFF2196F3)&#13;&#10;                                        else -&gt; MaterialTheme.colorScheme.primary&#13;&#10;                                    }&#13;&#10;                                    Box(&#13;&#10;                                        modifier = Modifier&#13;&#10;                                            .size(8.dp)&#13;&#10;                                            .background(color, CircleShape)&#13;&#10;                                    )&#13;&#10;                                }&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                    &#13;&#10;                    Spacer(modifier = Modifier.height(16.dp))&#13;&#10;                    &#13;&#10;                    Text(&#13;&#10;                        text = &quot;Sort By&quot;,&#13;&#10;                        style = MaterialTheme.typography.titleMedium,&#13;&#10;                        fontWeight = FontWeight.SemiBold,&#13;&#10;                        color = MaterialTheme.colorScheme.primary&#13;&#10;                    )&#13;&#10;                    &#13;&#10;                    Spacer(modifier = Modifier.height(12.dp))&#13;&#10;                    &#13;&#10;                    FlowRow(&#13;&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp),&#13;&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;                    ) {&#13;&#10;                        val sortOptions = listOf(&#13;&#10;                            SortType.CREATED_DATE to &quot;Created Date&quot;,&#13;&#10;                            SortType.DUE_DATE to &quot;Due Date&quot;,&#13;&#10;                            SortType.PRIORITY to &quot;Priority&quot;,&#13;&#10;                            SortType.ALPHABETICAL to &quot;A-Z&quot;,&#13;&#10;                            SortType.COMPLETION_STATUS to &quot;Status&quot;&#13;&#10;                        )&#13;&#10;                        &#13;&#10;                        sortOptions.forEach { (sort, label) -&gt;&#13;&#10;                            FilterChip(&#13;&#10;                                selected = selectedSort == sort,&#13;&#10;                                onClick = { onSortChange(sort) },&#13;&#10;                                label = { Text(label) }&#13;&#10;                            )&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/components/ViewToggleButton.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/components/ViewToggleButton.kt" />
              <option name="originalContent" value="package com.masum.todo.presentation.components&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.GridView&#10;import androidx.compose.material.icons.filled.ViewList&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.rotate&#10;import androidx.compose.ui.unit.dp&#10;&#10;@Composable&#10;fun ViewToggleButton(&#10;    isGridView: Boolean,&#10;    onToggleView: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val rotation by animateFloatAsState(&#10;        targetValue = if (isGridView) 0f else 180f,&#10;        animationSpec = tween(300),&#10;        label = &quot;view_toggle_rotation&quot;&#10;    )&#10;    &#10;    IconButton(&#10;        onClick = onToggleView,&#10;        colors = IconButtonDefaults.iconButtonColors(&#10;            contentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;        ),&#10;        modifier = modifier&#10;    ) {&#10;        Icon(&#10;            imageVector = if (isGridView) Icons.Default.ViewList else Icons.Default.GridView,&#10;            contentDescription = if (isGridView) &quot;Switch to list view&quot; else &quot;Switch to grid view&quot;,&#10;            modifier = Modifier&#10;                .size(24.dp)&#10;                .rotate(rotation)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.masum.todo.presentation.components&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ViewModule&#10;import androidx.compose.material.icons.filled.ViewList&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.IconButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.rotate&#10;import androidx.compose.ui.unit.dp&#10;&#10;@Composable&#10;fun ViewToggleButton(&#10;    isGridView: Boolean,&#10;    onToggleView: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val rotation by animateFloatAsState(&#10;        targetValue = if (isGridView) 0f else 180f,&#10;        animationSpec = tween(300),&#10;        label = &quot;view_toggle_rotation&quot;&#10;    )&#10;    &#10;    IconButton(&#10;        onClick = onToggleView,&#10;        colors = IconButtonDefaults.iconButtonColors(&#10;            contentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;        ),&#10;        modifier = modifier&#10;    ) {&#10;        Icon(&#10;            imageVector = if (isGridView) Icons.Filled.ViewList else Icons.Filled.ViewModule,&#10;            contentDescription = if (isGridView) &quot;Switch to list view&quot; else &quot;Switch to grid view&quot;,&#10;            modifier = Modifier&#10;                .size(24.dp)&#10;                .rotate(rotation)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/viewmodel/TodoUiState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/viewmodel/TodoUiState.kt" />
              <option name="originalContent" value="package com.masum.todo.presentation.viewmodel&#10;&#10;import com.masum.todo.domain.model.TaskColor&#10;import com.masum.todo.domain.model.TaskPriority&#10;import com.masum.todo.domain.model.TodoTask&#10;import java.util.Date&#10;&#10;enum class FilterType {&#10;    ALL,&#10;    TODAY,&#10;    OVERDUE,&#10;    COMPLETED,&#10;    PENDING,&#10;    HIGH_PRIORITY,&#10;    MEDIUM_PRIORITY,&#10;    LOW_PRIORITY,&#10;    WITH_DUE_DATE,&#10;    NO_DUE_DATE&#10;}&#10;&#10;enum class SortType {&#10;    CREATED_DATE,&#10;    DUE_DATE,&#10;    PRIORITY,&#10;    ALPHABETICAL,&#10;    COMPLETION_STATUS&#10;}&#10;&#10;data class TodoUiState(&#10;    val tasks: List&lt;TodoTask&gt; = emptyList(),&#10;    val filteredTasks: List&lt;TodoTask&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val showAddDialog: Boolean = false,&#10;    val showEditDialog: Boolean = false,&#10;    val showTaskEditor: Boolean = false,&#10;    val currentTaskHeading: String = &quot;&quot;,&#10;    val currentTaskBody: String = &quot;&quot;,&#10;    val currentTaskColor: TaskColor = TaskColor.DEFAULT,&#10;    val taskToEdit: TodoTask? = null,&#10;    val snackbarMessage: String? = null,&#10;    val isGridView: Boolean = true,&#10;    val searchQuery: String = &quot;&quot;,&#10;    val selectedFilter: FilterType = FilterType.ALL,&#10;    val selectedSort: SortType = SortType.CREATED_DATE,&#10;    val showSearchBar: Boolean = false,&#10;    val showFilterOptions: Boolean = false,&#10;    val taskEditorDraft: com.masum.todo.domain.model.TodoTask? = null,&#10;    val recentlyDeletedTask: com.masum.todo.domain.model.TodoTask? = null,&#10;    val showUndoSnackbar: Boolean = false&#10;)&#10;&#10;sealed class TodoUiEvent {&#10;    data object LoadTasks : TodoUiEvent()&#10;    data class AddTask(val heading: String, val body: String = &quot;&quot;) : TodoUiEvent()&#10;    data class AddAdvancedTask(&#10;        val heading: String,&#10;        val body: String,&#10;        val color: TaskColor,&#10;        val priority: TaskPriority,&#10;        val dueDate: Date?,&#10;        val tags: List&lt;String&gt;&#10;    ) : TodoUiEvent()&#10;    data class UpdateTask(val task: TodoTask) : TodoUiEvent()&#10;    data class DeleteTask(val task: TodoTask) : TodoUiEvent()&#10;    data object UndoDeleteTask : TodoUiEvent()&#10;    data class ToggleTaskCompletion(val task: TodoTask, val isCompleted: Boolean) : TodoUiEvent()&#10;    data object ShowAddDialog : TodoUiEvent()&#10;    data object HideAddDialog : TodoUiEvent()&#10;    data object ShowTaskEditor : TodoUiEvent()&#10;    data object HideTaskEditor : TodoUiEvent()&#10;    data class ShowEditDialog(val task: TodoTask) : TodoUiEvent()&#10;    data class ShowTaskEditorForEdit(val task: TodoTask) : TodoUiEvent()&#10;    data object HideEditDialog : TodoUiEvent()&#10;    data class UpdateCurrentTaskHeading(val heading: String) : TodoUiEvent()&#10;    data class UpdateCurrentTaskBody(val body: String) : TodoUiEvent()&#10;    data class UpdateCurrentTaskColor(val color: TaskColor) : TodoUiEvent()&#10;    data object ClearSnackbarMessage : TodoUiEvent()&#10;    data class ShowError(val message: String) : TodoUiEvent()&#10;    data object ToggleViewMode : TodoUiEvent()&#10;    data class UpdateSearchQuery(val query: String) : TodoUiEvent()&#10;    data class UpdateFilter(val filter: FilterType) : TodoUiEvent()&#10;    data class UpdateSort(val sort: SortType) : TodoUiEvent()&#10;    data object ToggleSearchBar : TodoUiEvent()&#10;    data object ToggleFilterOptions : TodoUiEvent()&#10;    data object ClearSearch : TodoUiEvent()&#10;&#10;    // Task Editor Draft events&#10;    data class SaveTaskEditorDraft(val draft: com.masum.todo.domain.model.TodoTask) : TodoUiEvent()&#10;    data object ClearTaskEditorDraft : TodoUiEvent()&#10;    data class UpdateDraftTags(val tags: List&lt;String&gt;) : TodoUiEvent()&#10;}&#10;" />
              <option name="updatedContent" value="package com.masum.todo.presentation.viewmodel&#13;&#10;&#13;&#10;import com.masum.todo.domain.model.TaskColor&#13;&#10;import com.masum.todo.domain.model.TaskPriority&#13;&#10;import com.masum.todo.domain.model.TodoTask&#13;&#10;import java.util.Date&#13;&#10;&#13;&#10;enum class FilterType {&#13;&#10;    ALL,&#13;&#10;    TODAY,&#13;&#10;    OVERDUE,&#13;&#10;    COMPLETED,&#13;&#10;    PENDING,&#13;&#10;    HIGH_PRIORITY,&#13;&#10;    MEDIUM_PRIORITY,&#13;&#10;    LOW_PRIORITY,&#13;&#10;    WITH_DUE_DATE,&#13;&#10;    NO_DUE_DATE&#13;&#10;}&#13;&#10;&#13;&#10;enum class SortType {&#13;&#10;    CREATED_DATE,&#13;&#10;    DUE_DATE,&#13;&#10;    PRIORITY,&#13;&#10;    ALPHABETICAL,&#13;&#10;    COMPLETION_STATUS&#13;&#10;}&#13;&#10;&#13;&#10;data class TodoUiState(&#13;&#10;    val tasks: List&lt;TodoTask&gt; = emptyList(),&#13;&#10;    val filteredTasks: List&lt;TodoTask&gt; = emptyList(),&#13;&#10;    val isLoading: Boolean = false,&#13;&#10;    val error: String? = null,&#13;&#10;    val showAddDialog: Boolean = false,&#13;&#10;    val showEditDialog: Boolean = false,&#13;&#10;    val showTaskEditor: Boolean = false,&#13;&#10;    val currentTaskHeading: String = &quot;&quot;,&#13;&#10;    val currentTaskBody: String = &quot;&quot;,&#13;&#10;    val currentTaskColor: TaskColor = TaskColor.DEFAULT,&#13;&#10;    val taskToEdit: TodoTask? = null,&#13;&#10;    val snackbarMessage: String? = null,&#13;&#10;    val isGridView: Boolean = true,&#13;&#10;    val searchQuery: String = &quot;&quot;,&#13;&#10;    val selectedFilter: FilterType = FilterType.ALL,&#13;&#10;    val selectedSort: SortType = SortType.CREATED_DATE,&#13;&#10;    val showSearchBar: Boolean = false,&#13;&#10;    val showFilterOptions: Boolean = false,&#13;&#10;    val taskEditorDraft: com.masum.todo.domain.model.TodoTask? = null,&#13;&#10;    val recentlyDeletedTask: com.masum.todo.domain.model.TodoTask? = null,&#13;&#10;    val showUndoSnackbar: Boolean = false&#13;&#10;)&#13;&#10;&#13;&#10;sealed class TodoUiEvent {&#13;&#10;    data object LoadTasks : TodoUiEvent()&#13;&#10;    data class AddTask(val heading: String, val body: String = &quot;&quot;) : TodoUiEvent()&#13;&#10;    data class AddAdvancedTask(&#13;&#10;        val heading: String,&#13;&#10;        val body: String,&#13;&#10;        val color: TaskColor,&#13;&#10;        val priority: TaskPriority,&#13;&#10;        val dueDate: Date?,&#13;&#10;        val tags: List&lt;String&gt;&#13;&#10;    ) : TodoUiEvent()&#13;&#10;    data class UpdateTask(val task: TodoTask) : TodoUiEvent()&#13;&#10;    data class DeleteTask(val task: TodoTask) : TodoUiEvent()&#13;&#10;    data object UndoDeleteTask : TodoUiEvent()&#13;&#10;    data class ToggleTaskCompletion(val task: TodoTask, val isCompleted: Boolean) : TodoUiEvent()&#13;&#10;    data object ShowAddDialog : TodoUiEvent()&#13;&#10;    data object HideAddDialog : TodoUiEvent()&#13;&#10;    data object ShowTaskEditor : TodoUiEvent()&#13;&#10;    data object HideTaskEditor : TodoUiEvent()&#13;&#10;    data class ShowEditDialog(val task: TodoTask) : TodoUiEvent()&#13;&#10;    data class ShowTaskEditorForEdit(val task: TodoTask) : TodoUiEvent()&#13;&#10;    data object HideEditDialog : TodoUiEvent()&#13;&#10;    data class UpdateCurrentTaskHeading(val heading: String) : TodoUiEvent()&#13;&#10;    data class UpdateCurrentTaskBody(val body: String) : TodoUiEvent()&#13;&#10;    data class UpdateCurrentTaskColor(val color: TaskColor) : TodoUiEvent()&#13;&#10;    data object ClearSnackbarMessage : TodoUiEvent()&#13;&#10;    data class ShowError(val message: String) : TodoUiEvent()&#13;&#10;    data object ToggleViewMode : TodoUiEvent()&#13;&#10;    data class UpdateSearchQuery(val query: String) : TodoUiEvent()&#13;&#10;    data class UpdateFilter(val filter: FilterType) : TodoUiEvent()&#13;&#10;    data class UpdateSort(val sort: SortType) : TodoUiEvent()&#13;&#10;    data object ToggleSearchBar : TodoUiEvent()&#13;&#10;    data object ToggleFilterOptions : TodoUiEvent()&#13;&#10;    data object ClearSearch : TodoUiEvent()&#13;&#10;    data class SaveTaskEditorDraft(val draft: com.masum.todo.domain.model.TodoTask) : TodoUiEvent()&#13;&#10;    data object ClearTaskEditorDraft : TodoUiEvent()&#13;&#10;    data class UpdateDraftTags(val tags: List&lt;String&gt;) : TodoUiEvent()&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/viewmodel/TodoViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/masum/todo/presentation/viewmodel/TodoViewModel.kt" />
              <option name="originalContent" value="package com.masum.todo.presentation.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.masum.todo.domain.model.TaskColor&#10;import com.masum.todo.domain.model.TaskPriority&#10;import com.masum.todo.domain.model.TodoTask&#10;import com.masum.todo.domain.repository.TodoRepository&#10;import com.masum.todo.utils.ErrorHandler&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.launch&#10;import java.util.Date&#10;import java.util.Calendar&#10;&#10;class TodoViewModel(&#10;    private val repository: TodoRepository&#10;) : ViewModel() {&#10;    &#10;    private val _uiState = MutableStateFlow(TodoUiState())&#10;    val uiState: StateFlow&lt;TodoUiState&gt; = _uiState.asStateFlow()&#10;    &#10;    init {&#10;        loadTasks()&#10;    }&#10;    &#10;    fun onEvent(event: TodoUiEvent) {&#10;        when (event) {&#10;            is TodoUiEvent.LoadTasks -&gt; loadTasks()&#10;            is TodoUiEvent.AddTask -&gt; addTask(event.heading, event.body)&#10;            is TodoUiEvent.AddAdvancedTask -&gt; addAdvancedTask(&#10;                event.heading, event.body, event.color, event.priority,&#10;                event.dueDate, event.tags&#10;            )&#10;            is TodoUiEvent.UpdateTask -&gt; updateTask(event.task)&#10;            is TodoUiEvent.DeleteTask -&gt; deleteTask(event.task)&#10;            is TodoUiEvent.ToggleTaskCompletion -&gt; toggleTaskCompletion(event.task, event.isCompleted)&#10;            is TodoUiEvent.ShowAddDialog -&gt; showAddDialog()&#10;            is TodoUiEvent.HideAddDialog -&gt; hideAddDialog()&#10;            is TodoUiEvent.ShowTaskEditor -&gt; showTaskEditor()&#10;            is TodoUiEvent.HideTaskEditor -&gt; hideTaskEditor()&#10;            is TodoUiEvent.ShowEditDialog -&gt; showEditDialog(event.task)&#10;            is TodoUiEvent.ShowTaskEditorForEdit -&gt; showTaskEditorForEdit(event.task)&#10;            is TodoUiEvent.HideEditDialog -&gt; hideEditDialog()&#10;            is TodoUiEvent.UpdateCurrentTaskHeading -&gt; updateCurrentTaskHeading(event.heading)&#10;            is TodoUiEvent.UpdateCurrentTaskBody -&gt; updateCurrentTaskBody(event.body)&#10;            is TodoUiEvent.UpdateCurrentTaskColor -&gt; updateCurrentTaskColor(event.color)&#10;            is TodoUiEvent.ClearSnackbarMessage -&gt; clearSnackbarMessage()&#10;            is TodoUiEvent.ShowError -&gt; showError(event.message)&#10;            is TodoUiEvent.ToggleViewMode -&gt; toggleViewMode()&#10;            is TodoUiEvent.UpdateSearchQuery -&gt; updateSearchQuery(event.query)&#10;            is TodoUiEvent.UpdateFilter -&gt; updateFilter(event.filter)&#10;            is TodoUiEvent.UpdateSort -&gt; updateSort(event.sort)&#10;            is TodoUiEvent.ToggleSearchBar -&gt; toggleSearchBar()&#10;            is TodoUiEvent.ToggleFilterOptions -&gt; toggleFilterOptions()&#10;            is TodoUiEvent.ClearSearch -&gt; clearSearch()&#10;            else -&gt; {}&#10;        }&#10;        when (event) {&#10;            is TodoUiEvent.SaveTaskEditorDraft -&gt; saveTaskEditorDraft(event.draft)&#10;            is TodoUiEvent.ClearTaskEditorDraft -&gt; clearTaskEditorDraft()&#10;            is TodoUiEvent.UpdateDraftTags -&gt; updateDraftTags(event.tags)&#10;            else -&gt; {}&#10;        }&#10;    }&#10;&#10;    private fun saveTaskEditorDraft(draft: TodoTask) {&#10;        _uiState.value = _uiState.value.copy(taskEditorDraft = draft)&#10;    }&#10;&#10;    private fun clearTaskEditorDraft() {&#10;        _uiState.value = _uiState.value.copy(taskEditorDraft = null)&#10;    }&#10;&#10;    private fun updateDraftTags(tags: List&lt;String&gt;) {&#10;        val draft = _uiState.value.taskEditorDraft&#10;        if (draft != null) {&#10;            _uiState.value = _uiState.value.copy(taskEditorDraft = draft.copy(tags = tags))&#10;        }&#10;    }&#10;&#10;    private fun loadTasks() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;            &#10;            try {&#10;                repository.getAllTasks()&#10;                    .catch { throwable -&gt;&#10;                        ErrorHandler.logError(&quot;Failed to load tasks&quot;, throwable)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isLoading = false,&#10;                            error = ErrorHandler.getErrorMessage(throwable)&#10;                        )&#10;                    }&#10;                    .collect { tasks -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            tasks = tasks,&#10;                            isLoading = false,&#10;                            error = null&#10;                        )&#10;                        applyFiltersAndSort()&#10;                    }&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Unexpected error while loading tasks&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = ErrorHandler.getErrorMessage(e)&#10;                )&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun addTask(heading: String, body: String) {&#10;        if (heading.isBlank()) {&#10;            showError(&quot;Task heading cannot be empty&quot;)&#10;            return&#10;        }&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val newTask = TodoTask(&#10;                    heading = heading.trim(),&#10;                    body = body.trim(),&#10;                    color = _uiState.value.currentTaskColor&#10;                )&#10;                repository.insertTask(newTask)&#10;                hideAddDialog()&#10;                clearCurrentTask()&#10;                showSnackbarMessage(&quot;Task added: ${newTask.heading}&quot;)&#10;                ErrorHandler.logError(&quot;Task added successfully: ${newTask.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to add task&quot;, e)&#10;                showError(&quot;Failed to add task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun updateTask(task: TodoTask) {&#10;        if (task.heading.isBlank()) {&#10;            showError(&quot;Task heading cannot be empty&quot;)&#10;            return&#10;        }&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                repository.updateTask(task)&#10;                hideTaskEditor()&#10;                showSnackbarMessage(&quot;Task updated: ${task.heading}&quot;)&#10;                ErrorHandler.logError(&quot;Task updated successfully: ${task.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to update task&quot;, e)&#10;                showError(&quot;Failed to update task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun deleteTask(task: TodoTask) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.deleteTask(task)&#10;                _uiState.value = _uiState.value.copy(&#10;                    recentlyDeletedTask = task,&#10;                    showUndoSnackbar = true,&#10;                    snackbarMessage = null&#10;                )&#10;                ErrorHandler.logError(&quot;Task deleted successfully: ${task.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to delete task&quot;, e)&#10;                showError(&quot;Failed to delete task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun undoDeleteTask() {&#10;        val task = _uiState.value.recentlyDeletedTask ?: return&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.insertTask(task)&#10;                _uiState.value = _uiState.value.copy(&#10;                    recentlyDeletedTask = null,&#10;                    showUndoSnackbar = false,&#10;                    snackbarMessage = null&#10;                )&#10;                // Don't show another snackbar immediately after undo to avoid conflicts&#10;                ErrorHandler.logError(&quot;Task restored successfully: ${task.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to restore task&quot;, e)&#10;                showError(&quot;Failed to restore task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun toggleTaskCompletion(task: TodoTask, isCompleted: Boolean) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedTask = task.copy(isCompleted = isCompleted)&#10;                repository.updateTask(updatedTask)&#10;                val status = if (isCompleted) &quot;completed&quot; else &quot;marked active&quot;&#10;                showSnackbarMessage(&quot;Task $status: ${task.heading}&quot;)&#10;                ErrorHandler.logError(&quot;Task completion toggled: ${task.heading} - $status&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to update task completion&quot;, e)&#10;                showError(&quot;Failed to update task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun addAdvancedTask(&#10;        heading: String,&#10;        body: String,&#10;        color: TaskColor,&#10;        priority: TaskPriority,&#10;        dueDate: Date?,&#10;        tags: List&lt;String&gt;&#10;    ) {&#10;        if (heading.isBlank()) {&#10;            showError(&quot;Task heading cannot be empty&quot;)&#10;            return&#10;        }&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val newTask = TodoTask(&#10;                    heading = heading.trim(),&#10;                    body = body.trim(),&#10;                    color = color,&#10;                    priority = priority,&#10;                    dueDate = dueDate,&#10;                    tags = tags&#10;                )&#10;                repository.insertTask(newTask)&#10;                hideTaskEditor()&#10;                showSnackbarMessage(&quot;Task created: ${newTask.heading}&quot;)&#10;                ErrorHandler.logError(&quot;Advanced task added successfully: ${newTask.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to add advanced task&quot;, e)&#10;                showError(&quot;Failed to create task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun showTaskEditor() {&#10;        _uiState.value = _uiState.value.copy(showTaskEditor = true)&#10;    }&#10;    &#10;    private fun hideTaskEditor() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showTaskEditor = false,&#10;            taskToEdit = null&#10;        )&#10;    }&#10;    &#10;    private fun showTaskEditorForEdit(task: TodoTask) {&#10;        _uiState.value = _uiState.value.copy(&#10;            showTaskEditor = true,&#10;            taskToEdit = task&#10;        )&#10;    }&#10;    &#10;    private fun showAddDialog() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showAddDialog = true,&#10;            currentTaskHeading = &quot;&quot;,&#10;            currentTaskBody = &quot;&quot;,&#10;            currentTaskColor = TaskColor.DEFAULT&#10;        )&#10;    }&#10;    &#10;    private fun hideAddDialog() {&#10;        _uiState.value = _uiState.value.copy(showAddDialog = false)&#10;        clearCurrentTask()&#10;    }&#10;    &#10;    private fun showEditDialog(task: TodoTask) {&#10;        _uiState.value = _uiState.value.copy(&#10;            showEditDialog = true,&#10;            taskToEdit = task,&#10;            currentTaskHeading = task.heading,&#10;            currentTaskBody = task.body,&#10;            currentTaskColor = task.color&#10;        )&#10;    }&#10;    &#10;    private fun hideEditDialog() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showEditDialog = false,&#10;            taskToEdit = null&#10;        )&#10;        clearCurrentTask()&#10;    }&#10;    &#10;    private fun updateCurrentTaskHeading(heading: String) {&#10;        _uiState.value = _uiState.value.copy(currentTaskHeading = heading)&#10;    }&#10;    &#10;    private fun updateCurrentTaskBody(body: String) {&#10;        _uiState.value = _uiState.value.copy(currentTaskBody = body)&#10;    }&#10;    &#10;    private fun updateCurrentTaskColor(color: TaskColor) {&#10;        _uiState.value = _uiState.value.copy(currentTaskColor = color)&#10;    }&#10;    &#10;    private fun clearCurrentTask() {&#10;        _uiState.value = _uiState.value.copy(&#10;            currentTaskHeading = &quot;&quot;,&#10;            currentTaskBody = &quot;&quot;,&#10;            currentTaskColor = TaskColor.DEFAULT&#10;        )&#10;    }&#10;    &#10;    private fun showSnackbarMessage(message: String) {&#10;        _uiState.value = _uiState.value.copy(snackbarMessage = message)&#10;    }&#10;    &#10;    private fun clearSnackbarMessage() {&#10;        _uiState.value = _uiState.value.copy(&#10;            snackbarMessage = null,&#10;            showUndoSnackbar = false,&#10;            recentlyDeletedTask = null&#10;        )&#10;    }&#10;    &#10;    private fun showError(message: String) {&#10;        _uiState.value = _uiState.value.copy(&#10;            error = message,&#10;            snackbarMessage = message&#10;        )&#10;    }&#10;    &#10;    private fun toggleViewMode() {&#10;        _uiState.value = _uiState.value.copy(&#10;            isGridView = !_uiState.value.isGridView&#10;        )&#10;    }&#10;    &#10;    private fun updateSearchQuery(query: String) {&#10;        _uiState.value = _uiState.value.copy(searchQuery = query)&#10;        applyFiltersAndSort()&#10;    }&#10;    &#10;    private fun updateFilter(filter: FilterType) {&#10;        _uiState.value = _uiState.value.copy(selectedFilter = filter)&#10;        applyFiltersAndSort()&#10;    }&#10;    &#10;    private fun updateSort(sort: SortType) {&#10;        _uiState.value = _uiState.value.copy(selectedSort = sort)&#10;        applyFiltersAndSort()&#10;    }&#10;    &#10;    private fun toggleSearchBar() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showSearchBar = !_uiState.value.showSearchBar,&#10;            showFilterOptions = false&#10;        )&#10;        if (!_uiState.value.showSearchBar) {&#10;            clearSearch()&#10;        }&#10;    }&#10;    &#10;    private fun toggleFilterOptions() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showFilterOptions = !_uiState.value.showFilterOptions,&#10;            showSearchBar = false&#10;        )&#10;    }&#10;    &#10;    private fun clearSearch() {&#10;        _uiState.value = _uiState.value.copy(&#10;            searchQuery = &quot;&quot;,&#10;            selectedFilter = FilterType.ALL,&#10;            showSearchBar = false,&#10;            showFilterOptions = false&#10;        )&#10;        applyFiltersAndSort()&#10;    }&#10;    &#10;    private fun applyFiltersAndSort() {&#10;        val tasks = _uiState.value.tasks&#10;        val searchQuery = _uiState.value.searchQuery.lowercase()&#10;        val filter = _uiState.value.selectedFilter&#10;        val sort = _uiState.value.selectedSort&#10;        &#10;        var filteredTasks = tasks&#10;        &#10;        if (searchQuery.isNotBlank()) {&#10;            filteredTasks = filteredTasks.filter { task -&gt;&#10;                task.heading.lowercase().contains(searchQuery) ||&#10;                task.body.lowercase().contains(searchQuery) ||&#10;                task.tags.any { it.lowercase().contains(searchQuery) }&#10;            }&#10;        }&#10;        &#10;        filteredTasks = when (filter) {&#10;            FilterType.ALL -&gt; filteredTasks&#10;            FilterType.TODAY -&gt; filteredTasks.filter { task -&gt;&#10;                task.dueDate?.let { dueDate -&gt;&#10;                    val today = Calendar.getInstance()&#10;                    val taskDate = Calendar.getInstance().apply { time = dueDate }&#10;                    today.get(Calendar.YEAR) == taskDate.get(Calendar.YEAR) &amp;&amp;&#10;                    today.get(Calendar.DAY_OF_YEAR) == taskDate.get(Calendar.DAY_OF_YEAR)&#10;                } ?: false&#10;            }&#10;            FilterType.OVERDUE -&gt; filteredTasks.filter { task -&gt;&#10;                task.dueDate?.let { dueDate -&gt;&#10;                    !task.isCompleted &amp;&amp; dueDate.before(Date())&#10;                } ?: false&#10;            }&#10;            FilterType.COMPLETED -&gt; filteredTasks.filter { it.isCompleted }&#10;            FilterType.PENDING -&gt; filteredTasks.filter { !it.isCompleted }&#10;            FilterType.HIGH_PRIORITY -&gt; filteredTasks.filter { it.priority == TaskPriority.HIGH }&#10;            FilterType.MEDIUM_PRIORITY -&gt; filteredTasks.filter { it.priority == TaskPriority.MEDIUM }&#10;            FilterType.LOW_PRIORITY -&gt; filteredTasks.filter { it.priority == TaskPriority.LOW }&#10;            FilterType.WITH_DUE_DATE -&gt; filteredTasks.filter { it.dueDate != null }&#10;            FilterType.NO_DUE_DATE -&gt; filteredTasks.filter { it.dueDate == null }&#10;        }&#10;        &#10;        filteredTasks = when (sort) {&#10;            SortType.CREATED_DATE -&gt; filteredTasks.sortedByDescending { it.createdAt }&#10;            SortType.DUE_DATE -&gt; filteredTasks.sortedWith(compareBy&lt;TodoTask&gt; { it.dueDate == null }.thenBy { it.dueDate })&#10;            SortType.PRIORITY -&gt; filteredTasks.sortedBy { it.priority.ordinal }&#10;            SortType.ALPHABETICAL -&gt; filteredTasks.sortedBy { it.heading.lowercase() }&#10;            SortType.COMPLETION_STATUS -&gt; filteredTasks.sortedBy { it.isCompleted }&#10;        }&#10;        &#10;        _uiState.value = _uiState.value.copy(filteredTasks = filteredTasks)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.masum.todo.presentation.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.masum.todo.domain.model.TaskColor&#10;import com.masum.todo.domain.model.TaskPriority&#10;import com.masum.todo.domain.model.TodoTask&#10;import com.masum.todo.domain.repository.TodoRepository&#10;import com.masum.todo.utils.ErrorHandler&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.launch&#10;import java.util.Date&#10;import java.util.Calendar&#10;&#10;class TodoViewModel(&#10;    private val repository: TodoRepository&#10;) : ViewModel() {&#10;    &#10;    private val _uiState = MutableStateFlow(TodoUiState())&#10;    val uiState: StateFlow&lt;TodoUiState&gt; = _uiState.asStateFlow()&#10;    &#10;    init {&#10;        loadTasks()&#10;    }&#10;    &#10;    fun onEvent(event: TodoUiEvent) {&#10;        when (event) {&#10;            is TodoUiEvent.LoadTasks -&gt; loadTasks()&#10;            is TodoUiEvent.AddTask -&gt; addTask(event.heading, event.body)&#10;            is TodoUiEvent.AddAdvancedTask -&gt; addAdvancedTask(&#10;                event.heading, event.body, event.color, event.priority,&#10;                event.dueDate, event.tags&#10;            )&#10;            is TodoUiEvent.UpdateTask -&gt; updateTask(event.task)&#10;            is TodoUiEvent.DeleteTask -&gt; deleteTask(event.task)&#10;            is TodoUiEvent.ToggleTaskCompletion -&gt; toggleTaskCompletion(event.task, event.isCompleted)&#10;            is TodoUiEvent.ShowAddDialog -&gt; showAddDialog()&#10;            is TodoUiEvent.HideAddDialog -&gt; hideAddDialog()&#10;            is TodoUiEvent.ShowTaskEditor -&gt; showTaskEditor()&#10;            is TodoUiEvent.HideTaskEditor -&gt; hideTaskEditor()&#10;            is TodoUiEvent.ShowEditDialog -&gt; showEditDialog(event.task)&#10;            is TodoUiEvent.ShowTaskEditorForEdit -&gt; showTaskEditorForEdit(event.task)&#10;            is TodoUiEvent.HideEditDialog -&gt; hideEditDialog()&#10;            is TodoUiEvent.UpdateCurrentTaskHeading -&gt; updateCurrentTaskHeading(event.heading)&#10;            is TodoUiEvent.UpdateCurrentTaskBody -&gt; updateCurrentTaskBody(event.body)&#10;            is TodoUiEvent.UpdateCurrentTaskColor -&gt; updateCurrentTaskColor(event.color)&#10;            is TodoUiEvent.ClearSnackbarMessage -&gt; clearSnackbarMessage()&#10;            is TodoUiEvent.ShowError -&gt; showError(event.message)&#10;            is TodoUiEvent.ToggleViewMode -&gt; toggleViewMode()&#10;            is TodoUiEvent.UpdateSearchQuery -&gt; updateSearchQuery(event.query)&#10;            is TodoUiEvent.UpdateFilter -&gt; updateFilter(event.filter)&#10;            is TodoUiEvent.UpdateSort -&gt; updateSort(event.sort)&#10;            is TodoUiEvent.ToggleSearchBar -&gt; toggleSearchBar()&#10;            is TodoUiEvent.ToggleFilterOptions -&gt; toggleFilterOptions()&#10;            is TodoUiEvent.ClearSearch -&gt; clearSearch()&#10;            else -&gt; {}&#10;        }&#10;        when (event) {&#10;            is TodoUiEvent.SaveTaskEditorDraft -&gt; saveTaskEditorDraft(event.draft)&#10;            is TodoUiEvent.ClearTaskEditorDraft -&gt; clearTaskEditorDraft()&#10;            is TodoUiEvent.UpdateDraftTags -&gt; updateDraftTags(event.tags)&#10;            else -&gt; {}&#10;        }&#10;    }&#10;&#10;    private fun saveTaskEditorDraft(draft: TodoTask) {&#10;        _uiState.value = _uiState.value.copy(taskEditorDraft = draft)&#10;    }&#10;&#10;    private fun clearTaskEditorDraft() {&#10;        _uiState.value = _uiState.value.copy(taskEditorDraft = null)&#10;    }&#10;&#10;    private fun updateDraftTags(tags: List&lt;String&gt;) {&#10;        val draft = _uiState.value.taskEditorDraft&#10;        if (draft != null) {&#10;            _uiState.value = _uiState.value.copy(taskEditorDraft = draft.copy(tags = tags))&#10;        }&#10;    }&#10;&#10;    private fun loadTasks() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;            &#10;            try {&#10;                repository.getAllTasks()&#10;                    .catch { throwable -&gt;&#10;                        ErrorHandler.logError(&quot;Failed to load tasks&quot;, throwable)&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isLoading = false,&#10;                            error = ErrorHandler.getErrorMessage(throwable)&#10;                        )&#10;                    }&#10;                    .collect { tasks -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            tasks = tasks,&#10;                            isLoading = false,&#10;                            error = null&#10;                        )&#10;                        applyFiltersAndSort()&#10;                    }&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Unexpected error while loading tasks&quot;, e)&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    error = ErrorHandler.getErrorMessage(e)&#10;                )&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun addTask(heading: String, body: String) {&#10;        if (heading.isBlank()) {&#10;            showError(&quot;Task heading cannot be empty&quot;)&#10;            return&#10;        }&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val newTask = TodoTask(&#10;                    heading = heading.trim(),&#10;                    body = body.trim(),&#10;                    color = _uiState.value.currentTaskColor&#10;                )&#10;                repository.insertTask(newTask)&#10;                hideAddDialog()&#10;                clearCurrentTask()&#10;                showSnackbarMessage(&quot;Task added: ${newTask.heading}&quot;)&#10;                ErrorHandler.logError(&quot;Task added successfully: ${newTask.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to add task&quot;, e)&#10;                showError(&quot;Failed to add task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun updateTask(task: TodoTask) {&#10;        if (task.heading.isBlank()) {&#10;            showError(&quot;Task heading cannot be empty&quot;)&#10;            return&#10;        }&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                repository.updateTask(task)&#10;                hideTaskEditor()&#10;                showSnackbarMessage(&quot;Task updated: ${task.heading}&quot;)&#10;                ErrorHandler.logError(&quot;Task updated successfully: ${task.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to update task&quot;, e)&#10;                showError(&quot;Failed to update task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun deleteTask(task: TodoTask) {&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.deleteTask(task)&#10;                _uiState.value = _uiState.value.copy(&#10;                    recentlyDeletedTask = task,&#10;                    showUndoSnackbar = true,&#10;                    snackbarMessage = null&#10;                )&#10;                ErrorHandler.logError(&quot;Task deleted successfully: ${task.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to delete task&quot;, e)&#10;                showError(&quot;Failed to delete task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun undoDeleteTask() {&#10;        val task = _uiState.value.recentlyDeletedTask ?: return&#10;        viewModelScope.launch {&#10;            try {&#10;                repository.insertTask(task)&#10;                _uiState.value = _uiState.value.copy(&#10;                    recentlyDeletedTask = null,&#10;                    showUndoSnackbar = false,&#10;                    snackbarMessage = null&#10;                )&#10;                ErrorHandler.logError(&quot;Task restored successfully: &quot;+task.heading)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to restore task&quot;, e)&#10;                showError(&quot;Failed to restore task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun toggleTaskCompletion(task: TodoTask, isCompleted: Boolean) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val updatedTask = task.copy(isCompleted = isCompleted)&#10;                repository.updateTask(updatedTask)&#10;                val status = if (isCompleted) &quot;completed&quot; else &quot;marked active&quot;&#10;                showSnackbarMessage(&quot;Task $status: ${task.heading}&quot;)&#10;                ErrorHandler.logError(&quot;Task completion toggled: ${task.heading} - $status&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to update task completion&quot;, e)&#10;                showError(&quot;Failed to update task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun addAdvancedTask(&#10;        heading: String,&#10;        body: String,&#10;        color: TaskColor,&#10;        priority: TaskPriority,&#10;        dueDate: Date?,&#10;        tags: List&lt;String&gt;&#10;    ) {&#10;        if (heading.isBlank()) {&#10;            showError(&quot;Task heading cannot be empty&quot;)&#10;            return&#10;        }&#10;        &#10;        viewModelScope.launch {&#10;            try {&#10;                val newTask = TodoTask(&#10;                    heading = heading.trim(),&#10;                    body = body.trim(),&#10;                    color = color,&#10;                    priority = priority,&#10;                    dueDate = dueDate,&#10;                    tags = tags&#10;                )&#10;                repository.insertTask(newTask)&#10;                hideTaskEditor()&#10;                showSnackbarMessage(&quot;Task created: ${newTask.heading}&quot;)&#10;                ErrorHandler.logError(&quot;Advanced task added successfully: ${newTask.heading}&quot;)&#10;            } catch (e: Exception) {&#10;                ErrorHandler.logError(&quot;Failed to add advanced task&quot;, e)&#10;                showError(&quot;Failed to create task: ${ErrorHandler.getErrorMessage(e)}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun showTaskEditor() {&#10;        _uiState.value = _uiState.value.copy(showTaskEditor = true)&#10;    }&#10;    &#10;    private fun hideTaskEditor() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showTaskEditor = false,&#10;            taskToEdit = null&#10;        )&#10;    }&#10;    &#10;    private fun showTaskEditorForEdit(task: TodoTask) {&#10;        _uiState.value = _uiState.value.copy(&#10;            showTaskEditor = true,&#10;            taskToEdit = task&#10;        )&#10;    }&#10;    &#10;    private fun showAddDialog() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showAddDialog = true,&#10;            currentTaskHeading = &quot;&quot;,&#10;            currentTaskBody = &quot;&quot;,&#10;            currentTaskColor = TaskColor.DEFAULT&#10;        )&#10;    }&#10;    &#10;    private fun hideAddDialog() {&#10;        _uiState.value = _uiState.value.copy(showAddDialog = false)&#10;        clearCurrentTask()&#10;    }&#10;    &#10;    private fun showEditDialog(task: TodoTask) {&#10;        _uiState.value = _uiState.value.copy(&#10;            showEditDialog = true,&#10;            taskToEdit = task,&#10;            currentTaskHeading = task.heading,&#10;            currentTaskBody = task.body,&#10;            currentTaskColor = task.color&#10;        )&#10;    }&#10;    &#10;    private fun hideEditDialog() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showEditDialog = false,&#10;            taskToEdit = null&#10;        )&#10;        clearCurrentTask()&#10;    }&#10;    &#10;    private fun updateCurrentTaskHeading(heading: String) {&#10;        _uiState.value = _uiState.value.copy(currentTaskHeading = heading)&#10;    }&#10;    &#10;    private fun updateCurrentTaskBody(body: String) {&#10;        _uiState.value = _uiState.value.copy(currentTaskBody = body)&#10;    }&#10;    &#10;    private fun updateCurrentTaskColor(color: TaskColor) {&#10;        _uiState.value = _uiState.value.copy(currentTaskColor = color)&#10;    }&#10;    &#10;    private fun clearCurrentTask() {&#10;        _uiState.value = _uiState.value.copy(&#10;            currentTaskHeading = &quot;&quot;,&#10;            currentTaskBody = &quot;&quot;,&#10;            currentTaskColor = TaskColor.DEFAULT&#10;        )&#10;    }&#10;    &#10;    private fun showSnackbarMessage(message: String) {&#10;        _uiState.value = _uiState.value.copy(snackbarMessage = message)&#10;    }&#10;    &#10;    private fun clearSnackbarMessage() {&#10;        _uiState.value = _uiState.value.copy(&#10;            snackbarMessage = null,&#10;            showUndoSnackbar = false,&#10;            recentlyDeletedTask = null&#10;        )&#10;    }&#10;    &#10;    private fun showError(message: String) {&#10;        _uiState.value = _uiState.value.copy(&#10;            error = message,&#10;            snackbarMessage = message&#10;        )&#10;    }&#10;    &#10;    private fun toggleViewMode() {&#10;        _uiState.value = _uiState.value.copy(&#10;            isGridView = !_uiState.value.isGridView&#10;        )&#10;    }&#10;    &#10;    private fun updateSearchQuery(query: String) {&#10;        _uiState.value = _uiState.value.copy(searchQuery = query)&#10;        applyFiltersAndSort()&#10;    }&#10;    &#10;    private fun updateFilter(filter: FilterType) {&#10;        _uiState.value = _uiState.value.copy(selectedFilter = filter)&#10;        applyFiltersAndSort()&#10;    }&#10;    &#10;    private fun updateSort(sort: SortType) {&#10;        _uiState.value = _uiState.value.copy(selectedSort = sort)&#10;        applyFiltersAndSort()&#10;    }&#10;    &#10;    private fun toggleSearchBar() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showSearchBar = !_uiState.value.showSearchBar,&#10;            showFilterOptions = false&#10;        )&#10;        if (!_uiState.value.showSearchBar) {&#10;            clearSearch()&#10;        }&#10;    }&#10;    &#10;    private fun toggleFilterOptions() {&#10;        _uiState.value = _uiState.value.copy(&#10;            showFilterOptions = !_uiState.value.showFilterOptions,&#10;            showSearchBar = false&#10;        )&#10;    }&#10;    &#10;    private fun clearSearch() {&#10;        _uiState.value = _uiState.value.copy(&#10;            searchQuery = &quot;&quot;,&#10;            selectedFilter = FilterType.ALL,&#10;            showSearchBar = false,&#10;            showFilterOptions = false&#10;        )&#10;        applyFiltersAndSort()&#10;    }&#10;    &#10;    private fun applyFiltersAndSort() {&#10;        val tasks = _uiState.value.tasks&#10;        val searchQuery = _uiState.value.searchQuery.lowercase()&#10;        val filter = _uiState.value.selectedFilter&#10;        val sort = _uiState.value.selectedSort&#10;        &#10;        var filteredTasks = tasks&#10;        &#10;        if (searchQuery.isNotBlank()) {&#10;            filteredTasks = filteredTasks.filter { task -&gt;&#10;                task.heading.lowercase().contains(searchQuery) ||&#10;                task.body.lowercase().contains(searchQuery) ||&#10;                task.tags.any { it.lowercase().contains(searchQuery) }&#10;            }&#10;        }&#10;        &#10;        filteredTasks = when (filter) {&#10;            FilterType.ALL -&gt; filteredTasks&#10;            FilterType.TODAY -&gt; filteredTasks.filter { task -&gt;&#10;                task.dueDate?.let { dueDate -&gt;&#10;                    val today = Calendar.getInstance()&#10;                    val taskDate = Calendar.getInstance().apply { time = dueDate }&#10;                    today.get(Calendar.YEAR) == taskDate.get(Calendar.YEAR) &amp;&amp;&#10;                    today.get(Calendar.DAY_OF_YEAR) == taskDate.get(Calendar.DAY_OF_YEAR)&#10;                } ?: false&#10;            }&#10;            FilterType.OVERDUE -&gt; filteredTasks.filter { task -&gt;&#10;                task.dueDate?.let { dueDate -&gt;&#10;                    !task.isCompleted &amp;&amp; dueDate.before(Date())&#10;                } ?: false&#10;            }&#10;            FilterType.COMPLETED -&gt; filteredTasks.filter { it.isCompleted }&#10;            FilterType.PENDING -&gt; filteredTasks.filter { !it.isCompleted }&#10;            FilterType.HIGH_PRIORITY -&gt; filteredTasks.filter { it.priority == TaskPriority.HIGH }&#10;            FilterType.MEDIUM_PRIORITY -&gt; filteredTasks.filter { it.priority == TaskPriority.MEDIUM }&#10;            FilterType.LOW_PRIORITY -&gt; filteredTasks.filter { it.priority == TaskPriority.LOW }&#10;            FilterType.WITH_DUE_DATE -&gt; filteredTasks.filter { it.dueDate != null }&#10;            FilterType.NO_DUE_DATE -&gt; filteredTasks.filter { it.dueDate == null }&#10;        }&#10;        &#10;        filteredTasks = when (sort) {&#10;            SortType.CREATED_DATE -&gt; filteredTasks.sortedByDescending { it.createdAt }&#10;            SortType.DUE_DATE -&gt; filteredTasks.sortedWith(compareBy&lt;TodoTask&gt; { it.dueDate == null }.thenBy { it.dueDate })&#10;            SortType.PRIORITY -&gt; filteredTasks.sortedBy { it.priority.ordinal }&#10;            SortType.ALPHABETICAL -&gt; filteredTasks.sortedBy { it.heading.lowercase() }&#10;            SortType.COMPLETION_STATUS -&gt; filteredTasks.sortedBy { it.isCompleted }&#10;        }&#10;        &#10;        _uiState.value = _uiState.value.copy(filteredTasks = filteredTasks)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    id(&quot;com.google.gms.google-services&quot;) apply false&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/settings.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/settings.gradle.kts" />
              <option name="originalContent" value="pluginManagement {&#10;    repositories {&#10;        google {&#10;            content {&#10;                includeGroupByRegex(&quot;com\\.android.*&quot;)&#10;                includeGroupByRegex(&quot;com\\.google.*&quot;)&#10;                includeGroupByRegex(&quot;androidx.*&quot;)&#10;            }&#10;        }&#10;        mavenCentral()&#10;        gradlePluginPortal()&#10;    }&#10;}&#10;dependencyResolutionManagement {&#10;    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)&#10;    repositories {&#10;        google()&#10;        mavenCentral()&#10;}&#10;&#10;rootProject.name = &quot;Todo&quot;&#10;include(&quot;:app&quot;)&#10;" />
              <option name="updatedContent" value="pluginManagement {&#13;&#10;    repositories {&#13;&#10;        google {&#13;&#10;            content {&#13;&#10;                includeGroupByRegex(&quot;com\\.android.*&quot;)&#13;&#10;                includeGroupByRegex(&quot;com\\.google.*&quot;)&#13;&#10;                includeGroupByRegex(&quot;androidx.*&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;        mavenCentral()&#13;&#10;        gradlePluginPortal()&#13;&#10;    }&#13;&#10;}&#13;&#10;dependencyResolutionManagement {&#13;&#10;    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)&#13;&#10;    repositories {&#13;&#10;        google()&#13;&#10;        mavenCentral()&#13;&#10;        maven(&quot;https://jitpack.io&quot;)&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;rootProject.name = &quot;Todo&quot;&#13;&#10;include(&quot;:app&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>